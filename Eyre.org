#+TITLE:                Eyre
#+AUTHOR:               Henrik Kjerringvåg
#+EMAIL:                henrik@kjerringvåg.no
#+STARTUP:              overview noindent
#+SEQ_TODO:             TODO(t) INPROGRESS(i) REVIEW(r@) | DONE(d) CANCELED(c@)
#+TAGS:                 cheatsheet(c) noexport(n)
#+OPTIONS:              toc:nil num:nil author:nil date:nil
#+EXPORT_EXCLUDE_TAGS:  noexport
#+LANGUAGE:             en

#+BEGIN_QUOTE
I am no bird; and no net ensnares me; I am a free human being with
an independent will
-- Jane Eyre
#+END_QUOTE

\newpage

* Introduction
  
OK, so with the obligatory hipster-quote out of the way, we can get
down to business. With Eyre, I'm trying to make my configuration as
immediately obvious as possible. As you might have noticed, it's geared
towards functional and literate programming first and foremost, but
can easily be tweaked to whatever your liking.
It's worth mentioning though that this is primarily my own
configuration and not a layered solution that you can update without
breakage.
  
  
* Package Management
  
Greately improve startup-performance by tweaking garbage-collection
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 64000000
      gc-cons-percentage 0.6)

(add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 800000
                                         gc-cons-percentage 0.1)))
#+END_SRC

We'll use a combination of [[https://github.com/jwiegley/use-package][use-package]] and [[https://github.com/raxod502/straight.el][straight.el]] to manage
packages.  Straight will clone all of the repositories, so you can
easily make changes and push them to your own fork.
#+BEGIN_SRC emacs-lisp
(let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 3))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+END_SRC
 
To set up your own fork, you simply supply a recipe to ~straight.el~
#+BEGIN_EXAMPLE emacs-lisp
(use-package el-patch
  :straight (el-patch :type git :host github :repo "your-name/el-patch"
                      :upstream (:host github
                                 :repo "raxod502/el-patch")))
#+END_EXAMPLE

 
* Configuration Helpers

#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :when (not (eq nil (getenv "EMACS_BENCHMARK")))
  :config (benchmark-init/activate)
  :init (add-hook 'after-init-hook #'benchmark-init/deactivate))
#+END_SRC  
  
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC  
 
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers than the current."
  (interactive)
  (mapc 'kill-buffer
	(delq (current-buffer)
	      (remove-if-not 'buffer-file-name (buffer-list)))))

(defun sudo-edit (&optional arg)
  "Edit currently visited file as root.

   With a prefix ARG prompt for a file to visit.
   Will also prompt for a file to visit if current
   buffer is not visiting a file."
  (interactive "P")
  (let ((cursor-position (point)))
    (if (or arg (not buffer-file-name))
	(find-file (concat "/sudo:root@localhost:"
			   (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name)))
    (goto-char cursor-position)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands (command-log-mode clm/toggle-command-log-buffer))
#+END_SRC
  
Macrostep is a handy little package that lets you expand elisp-macros.
  
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands (macrostep-mode macrostep-expand)
  :bind (("C-c e" . macrostep-expand)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package async
  :commands (async-bytecomp-allowed-packages dired-async-mode async-bytecomp-package-mode)
  :config (setq async-bytecomp-allowed-packages '(all))
  :init 
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+END_SRC
  
Whenever you'd like to test a package, you can use ~try~. Try will
download and run the package, but it will not be persisted to your
next session.
#+BEGIN_SRC emacs-lisp
(use-package try
  :commands try)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :commands super-save-mode
  :delight super-save-mode
  :config (setq super-save-auto-save-when-idle t
                auto-save-default nil)
  :init (super-save-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun add-hook-to-modes (modes hook)
  (dolist (mode modes)
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
	      hook)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(setq lisp-modes '(clojure
                   lisp
                   list-interaction
                   emacs-lisp))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(defconst src-file (expand-file-name "~/.eyre/Eyre.org"))
(defconst conf-dir (file-name-directory load-file-name))
(defconst savefile-dir (expand-file-name "savefile-dir" conf-dir))
(defconst backup-dir (expand-file-name "backup" conf-dir))
(setq backup-directory-alist `((".*" . , backup-dir))
      create-lockfiles nil
      auto-save-file-name-transforms `((".*" ,backup-dir t))
      auto-save-list-file-prefix backup-dir)
#+END_SRC  

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :commands exec-path-from-shell-initialize
  :config (exec-path-from-shell-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8-unix)
(set-language-environment "utf-8")
(set-selection-coding-system 'utf-8)
(setq locale-coding-system 'utf-8
      file-name-coding-system 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(defun find-configurations-file ()
  "Find Eyre's configuration-file."
  (interactive)
  (find-file src-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kill-term-buffer ()
  "Kill terminal-buffer upon quitting"
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'kill-term-buffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish :straight t)
(use-package delight :straight t)
#+END_SRC
 
  
* Terminal

#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :defer 1
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/usr/local/bin/bash")
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC


* Help

#+BEGIN_SRC emacs-lisp
(use-package tldr
  :commands tldr)
#+END_SRC


* Startup
  
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message ""
      initial-major-mode 'org-mode
      inhibit-startup-echo-area-message t)
#+END_SRC
  
By running ~emacs~ as a server, we can throw stuff at it from an
external command-line by executing ~emacsclient "path"~. I recommend
having an alias like: ~alias emacs="emacsclient -a '' -c "~, so that you
don't end up with multiple instances of emacs running at a time.
  
#+BEGIN_SRC emacs-lisp
(use-package server
  :if window-system
  :init (add-hook 'after-init-hook 'server-start t))
#+END_SRC
  
Eyre boots directly into the agenda-view, so you can quickly jump to
the task of the day. Getting comfortable with setting up an agenda will
make you more productive.
  
#+BEGIN_SRC emacs-lisp
(defun agenda ()
  (interactive)
  (org-agenda-list)
  (delete-other-windows))

(add-hook 'after-init-hook 'agenda)
#+END_SRC
  

* Navigation

#+BEGIN_SRC emacs-lisp
;(use-package ido-mode
;  :init (ido-mode 1))
#+END_SRC

Found this when googling https://gist.github.com/mwfogleman/95cc60c87a9323876c6c
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim ()
  "If the buffer is narrowed, it widens. Otherwise, it narrows to region, or Org subtree."
  (interactive)
  (cond ((buffer-narrowed-p) (widen))
	((region-active-p) (narrow-to-region (region-beginning) (region-end)))
	((equal major-mode 'org-mode) (org-narrow-to-subtree))
	(t (error "Please select a region to narrow to"))))

(bind-key "C-c n" 'narrow-or-widen-dwim)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package rg
  :commands rg)
#+END_SRC


* Menues
  
** Prefix-commands
   
#+BEGIN_SRC emacs-lisp
(define-prefix-command 'REPL)
(define-prefix-command 'buffers)
(define-prefix-command 'files)
(define-prefix-command 'git)
(define-prefix-command 'history)
(define-prefix-command 'projects)
(define-prefix-command 'toggle)
(define-prefix-command 'window)
#+END_SRC
   
** Aliases
   
Below is a list of aliases that makes it arguably easier to grok the
commands true purpose.
/Note that only commands without arguments will be possible to alias this way/

#+NAME: aliases
| alias                     | original                        |
|---------------------------+---------------------------------|
| buffers/kill              | kill-buffer                     |
| buffers/kill-other        | kill-other-buffers              |
| buffers/previous          | switch-to-prev-buffer           |
| buffers/list              | helm-mini                       |
| projects/find-file        | projectile-find-file            |
| projects/search           | helm-projectile-ag              |
| projects/last-search      | helm-resume                     |
| projects/switch           | projectile-persp-switch-project |
| window/kill               | persp-kill                      |
| window/rename             | persp-rename                    |
| window/switch             | persp-switch                    |
| window/switch-to-last     | persp-switch-last               |
| window/zoom               | text-scale-adjust               |
| window/split-vertically   | split-window-right              |
| window/split-horizontally | split-window-below              |
| toggle/fullscreen         | toggle-frame-fullscreen         |
| git/status                | magit-status                    |
| git/init                  | magit-init                      |
| git/log                   | magit-log-popup                 |
| git/diff                  | magit-diff-popup                |
| git/checkout              | magit-checkout                  |
| git/blame                 | magit-blame                     |
| git/pull                  | magit-pull                      |
| terminal                  | shell-pop                       |

Massage the table above into usable commands
#+BEGIN_SRC emacs-lisp :var aliases=aliases
(dolist (als (cdr aliases))
  (when (listp als)
    (defalias (intern (car als)) (intern (cadr als)))))
#+END_SRC

Some additional "aliases" that are interactive

#+BEGIN_SRC emacs-lisp
(defun buffers/scratch ()
  "Switch to existing or create a new scratch-buffer."
  (interactive)
  (switch-to-buffer-other-window (get-buffer-create "*scratch*")))
#+END_SRC


* Bindings							      :cheatsheet:

The global prefix-key is ~SPC~, after hitting space, you'll be presented
with a ~which-key~ menu with the following bindings

| Key-binding | Command                   |
|-------------+---------------------------|
| SPC         | avy-goto-word-1           |
| '           | terminal                  |
| /           | helm-resume               |
| a           | agenda                    |
| b           | buffers                   |
| bp          | buffers/previous          |
| bb          | buffers/list              |
| bk          | buffers/kill              |
| bo          | buffers/kill-other        |
| bs          | buffers/scratch           |
| f           | files                     |
| ff          | helm-find-files           |
| fc          | find-configurations-file  |
| fs          | sudo-edit                 |
| g           | git                       |
| gb          | git/blame                 |
| gi          | git/init                  |
| gl          | git/log                   |
| gs          | git/status                |
| gd          | git/diff                  |
| gc          | git/checkout              |
| gp          | git/pull                  |
| h           | history                   |
| hu          | undo-tree-visualize       |
| hk          | helm-show-kill-ring       |
| r           | REPL                      |
| p           | projects                  |
| p/          | projects/search           |
| pf          | projects/find-file        |
| ps          | projects/switch           |
| tf          | toggle/fullscreen         |
| w           | window                    |
| ws          | window/switch             |
| wr          | window/rename             |
| wl          | window/switch-to-last     |
| wk          | window/kill               |
| wz          | window/zoom               |
| w           | window/split-vertically   |
| w-          | window/split-horizontally |
  
#+BEGIN_SRC emacs-lisp
(use-package general
  :defer 1
  :config
  (setq general-default-keymaps 'evil-normal-state-map)
  (general-define-key :prefix "SPC"
                      "SPC" 'avy-goto-word-1
                      "'"  'terminal
                      "/"  'helm-resume
                      "a"  'agenda
                      "b"  'buffers
                      "bp" 'buffers/previous
                      "bb" 'buffers/list
                      "bk" 'buffers/kill
                      "bo" 'buffers/kill-other
                      "bs" 'buffers/scratch
                      "f"  'files
                      "ff" 'helm-find-files
                      "fc" 'find-configurations-file
                      "fs" 'sudo-edit
                      "g"  'git
                      "gb" 'git/blame
                      "gi" 'git/init
                      "gl" 'git/log
                      "gs" 'git/status
                      "gd" 'git/diff
                      "gc" 'git/checkout
                      "h"  'history
                      "hu" 'undo-tree-visualize
                      "hk" 'helm-show-kill-ring
                      "r"  'REPL
                      "p"  'projects
                      "p/" 'projects/search
                      "pf" 'projects/find-file
                      "ps" 'projects/switch
                      "tf" 'toggle/fullscreen
                      "w"  'window
                      "ws" 'window/switch
                      "wr" 'window/rename
                      "wl" 'window/switch-to-last
                      "wk" 'window/kill
                      "wz" 'window/zoom
                      "w|" 'window/split-vertically
                      "w-" 'window/split-horizontally)
  :init
  (general-evil-setup t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 1
  :diminish which-key-mode
  :config (which-key-setup-minibuffer)
  :init (which-key-mode))
#+END_SRC 
  

* Projects
  
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :commands (dumb-jump-mode dumb-jump-go-other-window)
  :config (setq dumb-jump-selector 'helm)
  :bind (("C-<tab>" . dumb-jump-go-other-window)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :commands (projectile-mode projectile-dired projectile-shell projectile-find-file)
  :diminish projectile-mode
  :config (setq projectile-completion-system 'helm)
  :init (projectile-global-mode))

(use-package perspective
  :config (persp-mode t)
  (use-package persp-projectile))

(use-package helm
  :defer 1
  :bind (("M-x" . helm-M-x))
  :config
  (progn
    (setq helm-quick-update t
          helm-candidate-number-limit 100
          helm-locate-command "mdfind -name %s %s"
          helm-ff-skip-boring-files t
          helm-autoresize-min-height 10
          helm-M-x-fuzzy-match t
          helm-mode-fuzzy-match t
          helm-apropos-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t)
    (helm-autoresize-mode t)))

(use-package helm-projectile
  :commands (helm-projectile-switch-project helm-projectile-find-file)
  :init (helm-projectile-on))

(use-package ag
  :commands (ag ag-project ag-regexp))

(use-package helm-ag
  :after ag
  :commands (helm-ag helm-ag-this-file))

(use-package avy
  :commands (avy-goto-line avy-goto-char-2)
  :bind (("M-g l" . avy-goto-line)
         ("M-g c" . avy-goto-char-2)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
;(use-package asana
;  :load-path "~/.eyre/packages/asana.el"
;  :commands asana-tasklist
;  :bind (("C-c a" . asana-tasklist)))
#+END_SRC


* Efficient Editing
  
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :defer 1)
#+END_SRC

Evil introduces modal-bindings to emacs, similar to that of vim. As a
longtime vim-user, I must say it's like editing super-powers that I
can not leave behind.

#+BEGIN_SRC emacs-lisp
;; (defun remove-first-occurance ()
;;   (interactive)
;;   (evil-ex "s//"))

(use-package evil
  ;; :bind ("C-s" . remove-first-occurance)
  :init (evil-mode 1))

(use-package evil-iedit-state
  :after evil)

(use-package evil-exchange
  :after evil)

(use-package evil-ediff
  :after evil)

(use-package evil-surround
  :after evil
  :init (global-evil-surround-mode 1))

(use-package evil-visualstar
  :after evil
  :config (setq evil-visualstar/persistent t)
  :init (global-evil-visualstar-mode))

(use-package evil-commentary
  :after evil
  :config (evil-commentary-mode))
#+END_SRC
  
  
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :config (setq key-chord-two-keys-delay 0.05))

(use-package use-package-chords
  :after key-chord
  :init (key-chord-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish  yas-minor-mode
  :config (yas/load-directory "~/.eyre/snippets")
  :init (yas-global-mode t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :commands (hs-show-all hs-hide-all)
  :diminish hideshow-mode
  :config (setq hs-hide-comments-when-hiding-all nil)
  :init (add-hook 'prog-mode-hook 'hs-minor-mode)
  :bind (:map hs-minor-mode-map
              ("S-<tab>" . hs-show-all)
              ("A-<tab>" . hs-hide-all)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
;(use-package chrome-emacsclient
;  :load-path "~/.eyre/packages/chrome-emacsclient"
;  :commands (chromeserv-find-file httpd/chromeserv/visit)
;  :after simple-httpd)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :commands (mc/mark-next-like-this mc/unmark-next-like-this mc/add-cursor-on-click)
  :bind (("M-." . mc/mark-next-like-this)
         ("M-," . mc/unmark-next-like-this)
         ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :config (setq-default save-place t))
#+END_SRC


* Version Control
  
Without this property set to true, you would most likely jump of a
cliff. It simply loads whatever changes that happens to files outside
of emacs. Usually happens when you switch branch etc.
  
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
  
[[https://magit.vc/][Magit]] is pretty much the de-facto interface for git in Emacs and for
good reasons. I've set it up so it suits my vim-mussles a little better.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-blame-mode
             magit-diff-popup
             magit-log-popup
             magit-statu)
  :config (general-define-key :prefix "SPC"))

(use-package magithub
  :disabled
  :after magit
  :config (magithub-feature-autoinject t))

(use-package evil-magit
  :after magit)
#+END_SRC
  
~diff-hl~ will highlight changes in the left-margin, very much like a
fringe. It will also highlight changes in dired etc, so it's slightly
more versatile than the more popular ~git-gutter~.
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :straight t
  :config (global-diff-hl-mode t))
#+END_SRC
  

* Services

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :commands (restclient-mode restclient-http-send-current restclient-copy-curl-command))
#+END_SRC


* Aesthetics
  
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :commands (golden-ratio golden-ratio-mode)
  :diminish golden-ratio-mode
  :config (add-hook 'post-command-hook 'golden-ratio)
  :init (golden-ratio-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package centered-cursor-mode
  :defer 1
  :delight centered-cursor-mode
  :config (global-centered-cursor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-default line-spacing 12
              linum-relative-current-symbol "")
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(setq-default comment-column 60)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 10000
      scroll-preserve-screen-position t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
(setq auto-revert-verbose nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer 1)

(use-package all-the-icons-dired
  :after all-the-icons
  :config (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package nord-theme
  :init (load-theme 'nord t))

(use-package material-theme
  :disabled
  :config
  (custom-theme-set-faces 'material
		  '(fringe ((t (:background "#181a26")))))
  :init (load-theme 'material :no-confirm))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :commands dimmer-mode
  :config (setq dimmer-percent 0.4
                dimmer-exclusion-regexp "^\*")
  :init (dimmer-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<A-up>") 'shrink-window)
(global-set-key (kbd "<A-down>") 'enlarge-window)
(global-set-key (kbd "<A-left>") 'shrink-window-horizontally)
(global-set-key (kbd "<A-right>") 'enlarge-window-horizontally)
#+END_SRC
  
I like using a GUI-version of Emacs, but I firmly dislike the amount
of chrome, this pretty much disables all of it for MacOS.
  
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(global-hl-line-mode)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(set-frame-font "Fira Code")

(use-package spinner
  :defer 1)

(use-package beacon
  :commands (beacon-mode)
  :diminish (beacon-mode . "")
  :config (beacon-mode t))

(use-package anzu
  :defer 1
  :diminish anzu-mode
  :config (global-anzu-mode t))

(use-package fullframe
  :commands magit-status
  :config (fullframe magit-status magit-mode-quit-window))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :commands linum-relative-mode
  :diminish linum-relative-mode
  :init
  (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :diminish rainbow-delimiters-mode
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :defer 1
  :diminish undo-tree-mode
  :config (defalias 'redo 'undo-tree-redo)
  :init (global-undo-tree-mode 1))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(diminish 'undo-tree-mode)
(diminish 'eldoc-mode)
(diminish 'auto-fill-function (string 32 #xa7))
(diminish 'auto-revert-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package telephone-line
  :after perspective
  :config 
  (progn
    (set-face-foreground 'persp-selected-face "SlateGrey")
    (setq projectile-mode-line
          '(:eval (if (file-remote-p default-directory)
                      " P"
                    (format " P[%s]" (projectile-project-name))))
          telephone-line-lhs
          '((evil   . (telephone-line-evil-tag-segment))
            (accent . (telephone-line-vc-segment
                       telephone-line-erc-modified-channels-segment
                       telephone-line-process-segment))
            (nil    . (telephone-line-minor-mode-segment
                       telephone-line-buffer-segment))))
    (setq telephone-line-rhs
          '((nil . (telephone-line-misc-info-segment))
            (evil . (telephone-line-major-mode-segment))))
    (setq telephone-line-primary-right-separator 'telephone-line-abs-left
          telephone-line-secondary-right-separator 'telephone-line-abs-hollow-left)
    (setq telephone-line-height 24
          telephone-line-evil-use-short-tag t))
  :init
  (telephone-line-evil-config))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package focus
  :commands focus-mode)
#+END_SRC


* Language Support

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC
  
Flycheck is an on the fly linter for a whole bunch of languages. For
some languages it might cause some performance-issues, so be aware.
  
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :defer 1
  :init (global-flycheck-mode))
#+END_SRC
  
Par-edit makes editing of s-expressions easier by keeping your
parenthesis balanced and adding key-bindings for some structural
modifications of code. It's mostly useful with lisps, but can also be
handy elsewhere as well, so learn par-edit. It's time well spent.
  
#+BEGIN_SRC emacs-lisp
(use-package paredit
  :commands paredit-mode
  :diminish paredit-mode
  :bind (("C-M-U" . paredit-forward-down))
  :init (add-hook-to-modes lisp-modes 'paredit-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package paxedit
  :commands paxedit-mode
  :diminish paxedit-mode
  :bind (:map paxedit-mode-map
              ("M-<right>" . paxedit-transpose-forward)
              ("M-<left>" . paxedit-transpose-backward)
              ("M-<up>" . paxedit-backward-up)
              ("M-<down>" . paxedit-backward-end)
              ("M-b" . paxedit-previous-symbol)
              ("M-f" . paxedit-next-symbol)
              ("C-%" . paxedit-copy)
              ("C-&" . paxedit-kill)
              ("C-*" . paxedit-delete)
              ("C-^" . paxedit-sexp-raise)
              ("C-w" . paxedit-backward-kill)
              ("M-w" . paxedit-forward-kill)
              ("M-u" . paxedit-symbol-change-case)
              ("C-@" . paxedit-symbol-copy)
              ("C-#" . paxedit-symbol-ki)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 1
  :diminish company-mode
  :init (global-company-mode))

(use-package company-quickhelp
  :after company
  :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :disabled
  :commands flyspell-mode
  :diminish flyspell-mode
  :config (setq ispell-program-name "aspell"
                ispell-extra-args '("--sug-mode=ultra"))
  :init (progn
          (add-hook 'text-mode-hook 'flyspell-mode)
          (add-hook 'git-commit-mode-hook 'flyspell-mode)
          (add-hook 'prog-mode-hook 'flyspell-prog-mode)))

(use-package auto-dictionary
  :disabled
  :commands auto-dictionary-mode
  :init (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package auto-highlight-symbol
  :straight t
  :config  (mapc (lambda (mode)
                (add-to-list 'ahs-modes mode))
              '(clojure-mode clojurescript-mode cider-repl-mode))
  :init (global-auto-highlight-symbol-mode t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
  (defun use-symbols ()
    "Translate some defined words into unicode symbols"
    (setq prettify-symbols-alist
	  '(("defn"       . ?ƒ)
	    ("defn-"      . ?ʄ)
	    ("#("         . (?ƒ (Br . Bl) ?())
	     ("fn"         . ?ƒ)
	     ("#{"         . (?∈ (Br . Bl) ?{))
	     ("->"         . ?→)
	     ("->>"        . ?⇒)
	     ("partial"    . ?Ƥ)
	     ("comp"       . ?∘)
	     ("alpha"      . ?α)
	     ("beta"       . ?β)
	     ("delta"      . ?Δ)
	     ;; ("delta-time" . '(?Δ (Br . Bl) ?T )
	     ("pi"         . ?π)
	     ("not="       . ?≠)
	     (">="         . ?≥)
	     ("<="         . ?≤)
	     ("true"       . ?✓)
	     ("false"      . ?✘))))
#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp
(defun clojure-hook ()
  (paredit-mode t)
  (paxedit-mode t)
  (eldoc-mode t)
  (subword-mode t)
  (rainbow-delimiters-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun zprint ()
  (interactive)
  (let ((cmd (concat "lein zprint " buffer-file-name)))
    (basic-save-buffer)
    (shell-command cmd)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package inf-clojure
  :after clojure-mode
  :init (inf-clojure-minor-mode))
#+END_SRC
   
#+BEGIN_SRC emacs-lisp
(defun cider-debug-create-local-let (start end)
  (interactive "r")
  (if cider--debug-mode-response
      (nrepl-dbind-response cider--debug-mode-response (locals)
        (let* ((code (buffer-substring-no-properties start end))
               (bindings (apply #'append locals))
               (formatted-bindings (mapconcat 'identity bindings " ")))
          (kill-new (format "(let [%s]\n %s)" formatted-bindings code))
          (message "copied let form to kill ring")))
    (message "No debugging information found.")))

(use-package cider
  :after clojure-mode
  :diminish cider-mode
  :bind (:map cider-mode-map
              ("C-c f" . zprint))
  :config
  (setq nrepl-log-messages t
        nrepl-buffer-name-show-port t
        cider-repl-pop-to-buffer-on-connect nil
        cider-font-lock-dynamically '(macro core function var)
        cider-overlays-use-font-lock t
        cider-eldoc-display-context-dependent-info t
        cider-repl-display-help-banner t
        cider-show-error-buffer t
        cider-auto-select-error-buffer t
        cider-repl-history-file "~/.eyre/cider-history"
        cider-repl-wrap-history t
        cider-repl-use-pretty-printing t
        cider-cljs-clojure-repl "clj -Sdeps '{:deps {org.clojure/clojurescript {:mvn/version \"1.10.64\"}}}' -m cljs.main -r"
        cider-boot-parameters "cider repl -s wait"
        cider-cljs-boot-repl "(future (boot (dev)))"
        cider-cljs-lein-repl "(do (require 'figwheel-sidecar.repl-api)
                                  (figwheel-sidecar.repl-api/start-figwheel!)
                                  (figwheel-sidecar.repl-api/cljs-repl))"
        cider-pprint-fn 'fipp)
  :init
  (add-hook 'clojure-mode-hook 'use-symbols)
  (add-hook 'cider-mode-hook #'clojure-hook)
  (add-hook 'cider-repl-mode-hook #'clojure-hook)
  (global-prettify-symbols-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;(use-package re-jump
;  :disabled
;  :load-path "~/.eyre/packages/re-jump.el")
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
(defun cider-format-before-save () 
  (interactive)
  (add-hook 'before-save-hook 'cider-format-buffer t t))

(use-package clojure-mode
  :defer 1
  :commands (clojure-mode clojurescript-mode clojurec-mode)
  :mode ("\\.edn$" "\\.boot$")
  :config
  (setq clojure-align-forms-automatically t
        clojure-indent-style ':always-align
        initial-scratch-message nil)
  :init 
  (add-hook 'clojure-mode-hook 'cider-format-before-save)
  (add-hook 'clojure-mode-hook 'cider-mode))
#+END_SRC
   
#+BEGIN_SRC emacs-lisp
(use-package clj-refactor
  :after cider-mode
  :diminish clj-refactor-mode
  :config (progn
            (setq cljr-warn-on-eval nil
                  cljr-magic-requires t
                  cljr-favor-prefix-notation nil
                  cljr-favor-private-functions nil
                  cljr-auto-sort-ns t
                  cljr-clojure-test-declaration "[clojure.test :refer :all]"
                  cljr-magic-require-namespaces
                  (append cljr-magic-require-namespaces
                          '(("edn"       . "clojure.edn")
                            ("spec"      . "clojure.spec")
                            ("stest"     . "clojure.spec.test")
                            ("str"       . "clojure.string"))))
            (cljr-add-keybindings-with-prefix "C-c e")
            (advice-add 'cljr-add-require-to-ns :after
                        (lambda (&rest _)
                          (yas-next-field)
                          (yas-next-field))))
  :init
  (add-hook 'clojure-mode-hook 'clj-refactor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flycheck-clojure
  :straight t
  :defer t
  :after (flycheck clojure-mode)
  :init (flycheck-clojure-setup))

(use-package flycheck-pos-tip
  :straight t
  :after (flycheck)
  :init (flycheck-pos-tip-mode))
#+END_SRC

*** Snippets

:PROPERTIES:
:mkdirp: true
:END:

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/c
# name: comment
# key: c
# --
(comment
  $0)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/wlet
# name: wlet
# key: wlet
# --
(when-let [$2 $1]
  $3)$>
  $0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/ilet
# name: ilet
# key: ilet
# --
(if-let [$2 $1]
  $3)$>
  $0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/cond
# name: cond
# key: cond
# --
(cond
  ($1) $2
  ($3) $4
  :else $5)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/try
# name: try
# key: try
# --
(try
  $1$>
  (catch ${2:Exception} e$>
    $3$>))$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/go
# name: timeout
# key: timeout
# --
(go (<! (timeout $1))
  ($0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-fx
# name: reg-event-fx
# key: fx
# --
(re-frame/reg-event-fx
  :$1
  (fn [{:keys [db]} [_ $2]]
    $0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-db
# name: reg-event-db
# key: db
# --
(re-frame/reg-event-db
  :$1
  (fn [db [_ $2]]
    $0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/log
# name: util/log
# key: l
# --
(util/log $0)
#+END_SRC

** Elm
   
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :config (setq elm-format-on-save t))

;(use-package flycheck-elm
;  :after (elm-mode flycheck)
;  :init (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC
   
** Org
   
#+BEGIN_SRC emacs-lisp :exports both
(defun org-mode-defaults ()
  (turn-on-auto-fill))

(use-package org
  :defer 1
  :bind (("C-c c" . org-capture))
  :config
  (require 'ob-tangle)
  (require 'ox-latex)
                                        ; (use-package org-habit)
  (load-library "find-lisp")
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (add-to-list 'org-latex-packages-alist '("" "listings"))
  (add-to-list 'org-latex-packages-alist '("" "color"))
  (setq org-directory (expand-file-name "~/org")
        org-default-notes-file (concat org-directory "/Notes.org")
        org-agenda-files (find-lisp-find-files org-directory "\.org$")
        org-agenda-start-with-follow-mode t
        org-hide-emphasis-markers t
        org-ditaa-jar-path "/usr/local/bin/ditaa"
        org-src-window-setup 'current-window
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0
        org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-latex-listings 'minted
        org-export-with-smart-quotes t
        org-ellipsis "•••"
        org-adapt-indentation nil
        org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl"))
        org-latex-listings 'minted
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((emacs-lisp . t)
           (dot . t)
           (org . t)
           (ditaa . t)
           (clojure . t)
           (css . t)
           (sh . t)
           (haskell . t)
           (makefile . t)
           (restclient . t))))
  (add-hook 'org-mode-hook 'org-mode-defaults))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-restclient
  :after (org restclient))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :defer 1)
#+END_SRC

I use some languages from org-mode more than others and it's kind of
tedious to write their full-name etc every time I want to blurb out
some code, so here's a few handy shortcuts

#+BEGIN_SRC emacs-lisp
                                        ; Clojure-code
(add-to-list 'org-structure-template-alist
             (list "clj" "#+BEGIN_SRC clojure\n?\n#+END_SRC" "<src lang=\"clojure\">\n?\n</src>"))

                                        ; Emacs-lisp-code
(add-to-list 'org-structure-template-alist
             (list "el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))

                                        ; Haskell-code
(add-to-list 'org-structure-template-alist
             (list "hs" "#+BEGIN_SRC haskell\n?\n#+END_SRC" "<src lang=\"haskell\">\n?\n</src>"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :defer t
  :after org)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :defer t
  :after org
  :config (setq org-bullets-bullet-list '("●"))
  :init (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

I'd like to get started journaling everything that affects my
well-being and progression. That means, I would like an entry for each
day that summarizes all my flaws and achievements. It will also need a
bit or two where I reflect upon it and possibly set a goal.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      `(("a" "Automate" entry (file+datetree ,(expand-file-name (concat org-directory "/Automation.org"))) "* %^{prompt}\n\n%?")
        ("j" "Jornal" entry (file+datetree ,(expand-file-name (concat org-directory "/Journal.org"))) "* %U %?\n%i\n")))
#+END_SRC

** Web

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 1
  :config (setq web-mode-markup-indent-offset 2
                web-mode-css-indent-offset 2
                web-mode-code-indent-offset 2
                web-mode-enable-auto-closing t
                web-mode-enable-auto-quoting t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer 1
  :init (add-hook-to-modes '(sgml-mode-hook css-mode-hook) 'emmet-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :defer 1
  :mode ("\\.js$'" . js2-mode)
  :bind (:map js2-mode-map
              ("{" . paredit-open-curly)
              ("}" . paredit-close-curly-and-newline))
  :init (custom-set-variables
         '(js2-basic-offset 2)
         '(js2-bounce-indent-p t)
         '(tab-width 2)
         '(indent-tabs-mode nil)
         '(js2-highlight-level 3)))

(use-package ac-js2
  :after js2-mode
  :init (progn
          (add-hook 'js-mode-hook 'js2-minor-mode)
          (add-hook 'js2-mode-hook 'ac-js2-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package prettier-js
  :defer 1
  :init (add-hook 'js2-mode-hook 'prettier-js-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-tern
  :defer 1
  :config (add-to-list 'company-backends 'company-tern))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package solidity-mode
  :straight t
  :commands (solidity-mode))
#+END_SRC


* Box-specific Preferences

#+BEGIN_SRC emacs-lisp
(let ((path (expand-file-name "~/.eyre.local")))
  (when (file-exists-p path)
      (load-file path)))
#+END_SRC


* Abbreviations

#+NAME: abbrev-table
| Abbreviation      | Full specimen |
|-------------------+---------------|
| very afraid       | terrified     |
| very angry        | furious       |
| very bad          | atrocious     |
| very beautiful    | exquisite     |
| very big          | immense       |
| very bright       | dazzling      |
| very capable      | accomplished  |
| very clean        | spotless      |
| very clever       | brilliant     |
| very cold         | freezing      |
| very conventional | conservative  |
| very dirty        | squalid       |
| very dry          | parched       |
| very eager        | keen          |
| very fast         | quick         |
| very fierce       | ferocious     |
| very good         | superb        |
| very happy        | jubilant      |
| very hot          | scalding      |
| very hungry       | ravenous      |
| very large        | colossal      |
| very lively       | vivacious     |
| very loved        | adored        |
| very neat         | immaculate    |
| very old          | ancient       |
| very poor         | destitute     |
| very pretty       | beautiful     |
| very quiet        | silent        |
| very risky        | perilous      |
| very roomy        | spacious      |
| very rude         | vulgar        |
| very serious      | solemn        |
| very small        | tiny          |
| very strong       | unyielding    |
| very stupid       | idiotic       |
| very tasty        | delicious     |
| very thin         | gaunt         |
| very tired        | exhausted     |
| very ugly         | hideous       |
| very valuable     | precious      |
| very weak         | feeble        |
| very wet          | soaked        |
| very wicked       | villainous    |
| very wise         | sagacious     |
| very worried      | anxious       |

** TODO Fix abbreviations-table
There's something off about the data-format
#+BEGIN_SRC emacs-lisp :var abbrev-table=abbrev-table
;; (let* ((dyn `(("@name" . ,user-full-name)
;;               ("@mail" . ,user-mail-address)))
;;        (abbreviations (concat dyn abbrev-table)))
;;   (define-abbrev-table 'global-abbrev-table abbreviations))
#+END_SRC


* Notes of Improvement

** TODO When reloading Eyre, perspectives should be conserved
** TODO Automatically open browser when connecting to a browser-REPL
