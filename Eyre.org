#+TITLE:                Eyre
#+AUTHOR:               Henrik Kjerringv√•g
#+EMAIL:                henrik@kjerringv√•g.no
#+STARTUP:              overview noindent
#+SEQ_TODO:             TODO(t) INPROGRESS(i) REVIEW(r@) | DONE(d) CANCELED(c@)
#+TAGS:                 cheatsheet(c) noexport(n)
#+OPTIONS:              toc:nil num:nil author:nil date:nil
#+EXPORT_EXCLUDE_TAGS:  noexport
#+LANGUAGE:             en
#+PROPERTY:             header-args :mkdirp yes :noweb yes

#+BEGIN_QUOTE
I am no bird; and no net ensnares me; I am a free human being with
an independent will
-- Jane Eyre
#+END_QUOTE

\newpage

* Introduction
  
OK, so with the obligatory hipster-quote out of the way, we can get
down to business. With Eyre, I'm trying to make my configuration as
immediately obvious as possible. As you might have noticed, it's geared
towards functional and literate programming first and foremost, but
can easily be tweaked to whatever your liking.
It's worth mentioning though that this is primarily my own
configuration and not a layered solution that you can update without
breakage.
  
  
* Package Management
  
Before downloading and installing any packages, I highly recommend a
tweak to the garbage-collector. These few lines will speed up
boot-time quite a bit and will allow your emacs-client to run smoothly
for weeks.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 64000000
      gc-cons-percentage 0.6)

(add-hook 'after-init-hook #'(lambda () (setq gc-cons-threshold 800000
                                         gc-cons-percentage 0.1)))
#+END_SRC

To actually manage packages, I like the combination of [[https://github.com/jwiegley/use-package][use-package]] and
[[https://github.com/raxod502/straight.el][straight.el]].  Straight will clone all of the repositories, so you can
actually make changes and push them to your own fork quite seamlessly.
#+BEGIN_SRC emacs-lisp
(let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 3))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+END_SRC
 
To set up your own fork, you supply a recipe to ~straight.el~ like this:
#+BEGIN_EXAMPLE emacs-lisp
(use-package el-patch
  :straight (el-patch :type git :host github :repo "your-name/el-patch"
                      :upstream (:host github
                                 :repo "raxod502/el-patch")))
#+END_EXAMPLE

 
* Configuration Helpers

From time and again, my configuration accumulate some cruft that
weighs it down. Starting emacs with ~EMACS_BENCHMARK~ set to true
can be quite helpful in finding the culprit.
#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :when (not (eq nil (getenv "EMACS_BENCHMARK")))
  :config (benchmark-init/activate)
  :init (add-hook 'after-init-hook #'benchmark-init/deactivate))
#+END_SRC  

Use ~y~ and ~n~ instead of ~yes~ and ~no~ when answering silly questions.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC  
 
Sometimes it's nice to just kill all other buffers than the one your
currently editing to get a clean slate.
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers than the current."
  (interactive)
  (mapc 'kill-buffer
	(delq (current-buffer)
	      (remove-if-not 'buffer-file-name (buffer-list)))))
#+END_SRC

If you ask me, editing as sudo should have been part of the stack of
emacs native commands, but hey..
#+BEGIN_SRC emacs-lisp
(defun sudo-edit (&optional arg)
  "Edit currently visited file as root.

   With a prefix ARG prompt for a file to visit.
   Will also prompt for a file to visit if current
   buffer is not visiting a file."
  (interactive "P")
  (let ((cursor-position (point)))
    (if (or arg (not buffer-file-name))
	(find-file (concat "/sudo:root@localhost:"
			   (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name)))
    (goto-char cursor-position)))
#+END_SRC

I haven't needed [[https://github.com/lewang/command-log-mode][command-log-mode]] that much, but it might come in
handy if I ever need to screencast a package I've made.
#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands (command-log-mode clm/toggle-command-log-buffer))
#+END_SRC
  
[[https://github.com/joddie/macrostep][Macrostep]] is a handy little package that lets you expand elisp-macros.
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands (macrostep-mode macrostep-expand)
  :bind (("C-c e" . macrostep-expand)))
#+END_SRC

[[https://github.com/jwiegley/emacs-async][Async]] does exactly what it sounds like. It can run commands
asynchronously. You can use it to byte-compile Eyre with a little
performance-boost.
#+BEGIN_SRC emacs-lisp
(use-package async
  :commands (dired-async-mode async-bytecomp-package-mode)
  :config (setq async-bytecomp-allowed-packages '(all))
  :init 
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+END_SRC
  
Whenever you'd like to test a package, you can use ~try~. Try will
download and run the package, but it will not be persisted to your
next session. Give it a try üòù
#+BEGIN_SRC emacs-lisp
(use-package try
  :commands try)
#+END_SRC

[[https://github.com/bbatsov/super-save][Super-save]] will automatically persist your buffers to files upon
certain events. Typically when emacs looses focus or you switch
between buffers etc.
#+BEGIN_SRC emacs-lisp
(use-package super-save
  :commands super-save-mode
  :delight super-save-mode
  :config (setq super-save-auto-save-when-idle t
                auto-save-default nil)
  :init (super-save-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun add-hook-to-modes (modes hook)
  (dolist (mode modes)
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
	      hook)))
#+END_SRC
  
 
#+BEGIN_SRC emacs-lisp
(defconst src-file (expand-file-name "~/.eyre/Eyre.org"))
(defconst conf-dir (file-name-directory load-file-name))
(defconst savefile-dir (expand-file-name "savefile-dir" conf-dir))
(defconst backup-dir (expand-file-name "backup" conf-dir))
(setq backup-directory-alist `((".*" . , backup-dir))
      create-lockfiles nil
      auto-save-file-name-transforms `((".*" ,backup-dir t))
      auto-save-list-file-prefix backup-dir)
(setq large-file-warning-threshold 100000000)
#+END_SRC  

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :commands exec-path-from-shell-initialize
  :config (exec-path-from-shell-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8-unix)
(set-language-environment "utf-8")
(set-selection-coding-system 'utf-8)
(setq locale-coding-system 'utf-8
      file-name-coding-system 'utf-8-unix)
(setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(defun find-configurations-file ()
  "Find Eyre's configuration-file."
  (interactive)
  (find-file src-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kill-term-buffer ()
  "Kill terminal-buffer upon quitting"
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'kill-term-buffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish :straight t)
(use-package delight :straight t)
#+END_SRC
 
  
* Terminal

#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :defer 1
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/usr/local/bin/bash")
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC
          
 
* Help

#+BEGIN_SRC emacs-lisp
(use-package tldr :commands tldr)
#+END_SRC


* Startup
  
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message ""
      initial-major-mode 'org-mode
      inhibit-startup-echo-area-message t
      load-prefer-newer t)
#+END_SRC
  
By running ~emacs~ as a server, we can throw stuff at it from an
external command-line by executing ~emacsclient "path"~. I recommend
having an alias like: ~alias emacs="emacsclient -a '' -c "~, so that you
don't end up with multiple instances of emacs running at a time.
  
#+BEGIN_SRC emacs-lisp
(use-package server
  :if window-system
  :init (add-hook 'after-init-hook 'server-start t))
#+END_SRC
  
Eyre boots directly into the agenda-view, so you can quickly jump to
the task of the day. Getting comfortable with setting up an agenda will
make you more productive.
  
#+BEGIN_SRC emacs-lisp
(defun agenda ()
  (interactive)
  (org-agenda-list)
  (delete-other-windows))

(add-hook 'after-init-hook 'agenda)
#+END_SRC
                                    
 
* Navigation

Found this when googling https://gist.github.com/mwfogleman/95cc60c87a9323876c6c
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim ()
  "If the buffer is narrowed, it widens. Otherwise, it narrows to region, or Org subtree."
  (interactive)
  (cond ((buffer-narrowed-p) (widen))
	((region-active-p) (narrow-to-region (region-beginning) (region-end)))
	((equal major-mode 'org-mode) (org-narrow-to-subtree))
	(t (error "Please select a region to narrow to"))))

(bind-key "C-c n" 'narrow-or-widen-dwim)
#+END_SRC

Enable mouse-support
#+BEGIN_SRC emacs-lisp
(xterm-mouse-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rg
  :commands rg)
#+END_SRC
                             
 
* Menues
  
** Prefix-commands
   
#+BEGIN_SRC emacs-lisp
(define-prefix-command 'REPL)
(define-prefix-command 'buffers)
(define-prefix-command 'files)
(define-prefix-command 'git)
(define-prefix-command 'history)
(define-prefix-command 'projects)
(define-prefix-command 'toggle)
(define-prefix-command 'window)
#+END_SRC
   
** Aliases
   
Below is a list of aliases that makes it arguably easier to grok the
commands true purpose.
/Note that only commands without arguments will be possible to alias this way/

#+NAME: aliases
| alias                     | original                        |
|---------------------------+---------------------------------|
| buffers/kill              | kill-buffer                     |
| buffers/kill-other        | kill-other-buffers              |
| buffers/previous          | switch-to-prev-buffer           |
| buffers/list              | helm-mini                       |
| projects/find-file        | projectile-find-file            |
| projects/search           | helm-projectile-ag              |
| projects/last-search      | helm-resume                     |
| projects/switch           | projectile-persp-switch-project |
| window/kill               | persp-kill                      |
| window/rename             | persp-rename                    |
| window/switch             | persp-switch                    |
| window/switch-to-last     | persp-switch-last               |
| window/zoom               | text-scale-adjust               |
| window/split-vertically   | split-window-right              |
| window/split-horizontally | split-window-below              |
| toggle/fullscreen         | toggle-frame-fullscreen         |
| git/status                | magit-status                    |
| git/init                  | magit-init                      |
| git/log                   | magit-log-popup                 |
| git/diff                  | magit-diff-popup                |
| git/checkout              | magit-checkout                  |
| git/blame                 | magit-blame                     |
| git/pull                  | magit-pull                      |
| terminal                  | shell-pop                       |

Massage the table above into usable commands
#+BEGIN_SRC emacs-lisp :var aliases=aliases
(dolist (als (cdr aliases))
  (when (listp als)
    (defalias (intern (car als)) (intern (cadr als)))))
#+END_SRC

Some additional "aliases" that are interactive

#+BEGIN_SRC emacs-lisp
(defun buffers/scratch ()
  "Switch to existing or create a new scratch-buffer."
  (interactive)
  (switch-to-buffer-other-window (get-buffer-create "*scratch*")))
#+END_SRC
                                                                
 
* Bindings                                                       :cheatsheet:

The global prefix-key is ~SPC~, after hitting space, you'll be presented
with a ~which-key~ menu with the following bindings

| Key-binding | Command                   |
|-------------+---------------------------|
| SPC         | avy-goto-word-1           |
| '           | terminal                  |
| /           | helm-resume               |
| a           | agenda                    |
| b           | buffers                   |
| bp          | buffers/previous          |
| bb          | buffers/list              |
| bk          | buffers/kill              |
| bo          | buffers/kill-other        |
| bs          | buffers/scratch           |
| f           | files                     |
| ff          | helm-find-files           |
| fc          | find-configurations-file  |
| fs          | sudo-edit                 |
| g           | git                       |
| gb          | git/blame                 |
| gi          | git/init                  |
| gl          | git/log                   |
| gs          | git/status                |
| gd          | git/diff                  |
| gc          | git/checkout              |
| gp          | git/pull                  |
| h           | history                   |
| hu          | undo-tree-visualize       |
| hk          | helm-show-kill-ring       |
| r           | REPL                      |
| p           | projects                  |
| p/          | projects/search           |
| pf          | projects/find-file        |
| ps          | projects/switch           |
| tf          | toggle/fullscreen         |
| w           | window                    |
| ws          | window/switch             |
| wr          | window/rename             |
| wl          | window/switch-to-last     |
| wk          | window/kill               |
| wz          | window/zoom               |
| w           | window/split-vertically   |
| w-          | window/split-horizontally |
  
#+BEGIN_SRC emacs-lisp
(use-package general
  :defer 1
  :config
  (setq general-default-keymaps 'evil-normal-state-map)
  (general-define-key :prefix "SPC"
                      "SPC" 'avy-goto-word-1
                      "'"  'terminal
                      "/"  'helm-resume
                      "a"  'agenda
                      "b"  'buffers
                      "bp" 'buffers/previous
                      "bb" 'buffers/list
                      "bk" 'buffers/kill
                      "bo" 'buffers/kill-other
                      "bs" 'buffers/scratch
                      "f"  'files
                      "ff" 'helm-find-files
                      "fc" 'find-configurations-file
                      "fs" 'sudo-edit
                      "g"  'git
                      "gb" 'git/blame
                      "gi" 'git/init
                      "gl" 'git/log
                      "gs" 'git/status
                      "gd" 'git/diff
                      "gc" 'git/checkout
                      "h"  'history
                      "hu" 'undo-tree-visualize
                      "hk" 'helm-show-kill-ring
                      "r"  'REPL
                      "p"  'projects
                      "p/" 'projects/search
                      "pf" 'projects/find-file
                      "ps" 'projects/switch
                      "tf" 'toggle/fullscreen
                      "w"  'window
                      "ws" 'window/switch
                      "wr" 'window/rename
                      "wl" 'window/switch-to-last
                      "wk" 'window/kill
                      "wz" 'window/zoom
                      "w|" 'window/split-vertically
                      "w-" 'window/split-horizontally)
  :init
  (general-evil-setup t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 1
  :diminish which-key-mode
  :config (which-key-setup-minibuffer)
  :init (which-key-mode))
#+END_SRC 
  
Hydrated bindings
#+BEGIN_SRC emacs-lisp
(use-package hydra :straight t)
(use-package dash :straight t)
(use-package s :straight t)

(use-package major-mode-hydra
  :straight (major-mode-hydra :type git :host github :repo "hkjels/major-mode-hydra.el"
                              :upstream (:host github
                                         :repo "jerrypnz/major-mode-hydra.el"))
  :config 
  (require 'hydra)
  (require 'dash)
  (require 's)
  (major-mode-hydra-bind clojurec-mode "Connect"
    ("j" cider-jack-in "jack-in")
    ("J" cider-jack-in-clojurescript "jack-in-cljs")
    ("c" cider-connect "connect")
    ("R" cider-restart "restart")
    ("Q" cider-quit "quit"))

  (major-mode-hydra-bind clojurec-mode "Load"
    ("k" cider-load-buffer "buffer")
    ("l" cider-load-file "file")
    ("L" cider-load-all-project-ns "all-ns")
    ("r" cider-refresh "reload"))
  :bind ("C-M-m" . major-mode-hydra))
#+END_SRC
                                                                                                                                   
 
* Projects
  
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :commands (dumb-jump-mode dumb-jump-go-other-window)
  :config (setq dumb-jump-selector 'helm)
  :bind (("C-<tab>" . dumb-jump-go-other-window)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(defun open-project-at ()
  (cond ((file-exists-p (concat default-directory "/README*")) (find-file (concat default-directory "/README*")))
        ((file-exists-p (concat default-directory "/.git")) (magit-status))
        (t (projectile-find-file))))

(use-package projectile
  :straight t
  :commands (projectile-mode projectile-dired projectile-shell projectile-find-file)
  :diminish projectile-mode
  :config (setq projectile-completion-system 'helm
		            projectile-switch-project-action 'open-project-at)
  :init (projectile-global-mode))

(use-package perspective
  :straight (perspective :type git :host github :repo "hkjels/perspective-el" :branch "no-frame-local-vars"
                              :upstream (:host github
                                         :repo "nex3/perspective-el"))
  :config (persp-mode t))

(use-package persp-projectile
  :straight (persp-projectile :type git :host github :repo "hkjels/persp-projectile" :branch "frame-perspective-hash"
                              :upstream (:host github
                                         :repo "bbatsov/persp-projectile"))
  :after (perspective projectile))

(use-package helm
  :defer 1
  :bind (("M-x" . helm-M-x))
  :config
  (progn
    (setq helm-quick-update t
	  helm-candidate-number-limit 100
	  helm-locate-command "mdfind -name %s %s"
	  helm-ff-skip-boring-files t
	  helm-autoresize-min-height 10
	  helm-M-x-fuzzy-match t
	  helm-mode-fuzzy-match t
	  helm-apropos-fuzzy-match t
	  helm-buffers-fuzzy-matching t
	  helm-recentf-fuzzy-match t)
    (helm-autoresize-mode t)))

(use-package helm-flx
  :straight t
  :init (helm-flx-mode +1))

(use-package helm-projectile
  :commands (helm-projectile-switch-project helm-projectile-find-file)
  :init (helm-projectile-on))

(use-package ag
  :commands (ag ag-project ag-regexp))

(use-package helm-ag
  :after ag
  :commands (helm-ag helm-ag-this-file))

(use-package avy
  :commands (avy-goto-line avy-goto-char-2 avy-goto-word-1)
  :bind (("M-g l" . avy-goto-line)
	       ("M-g c" . avy-goto-char-2)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
;(use-package asana
;  :load-path "~/.eyre/packages/asana.el"
;  :commands asana-tasklist
;  :bind (("C-c a" . asana-tasklist)))
#+END_SRC
                                                                                 
 
* Efficient Editing
  
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :defer 1)
#+END_SRC

Evil introduces modal-bindings to emacs, similar to that of vim. As a
longtime vim-user, I must say it's like editing super-powers that I
can not leave behind.

#+BEGIN_SRC emacs-lisp
(use-package evil :init (evil-mode 1))

(use-package evil-iedit-state :after evil)

(use-package evil-exchange :after evil)

(use-package evil-ediff :after evil)

(use-package evil-surround
  :after evil
  :init (global-evil-surround-mode 1))

(use-package evil-visualstar
  :after evil
  :config (setq evil-visualstar/persistent t)
  :init (global-evil-visualstar-mode))

(use-package evil-commentary
  :after evil
  :config (evil-commentary-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :config (setq key-chord-two-keys-delay 0.05))

(use-package use-package-chords
  :after key-chord
  :init (key-chord-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish  yas-minor-mode
  :config (yas/load-directory "~/.eyre/snippets")
  :init (yas-global-mode t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :commands (hs-show-all hs-hide-all)
  :diminish hideshow-mode
  :config (setq hs-hide-comments-when-hiding-all nil)
  :init (add-hook 'prog-mode-hook 'hs-minor-mode)
  :bind (:map hs-minor-mode-map
              ("S-<tab>" . hs-show-all)
              ("A-<tab>" . hs-hide-all)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
;(use-package chrome-emacsclient
;  :load-path "~/.eyre/packages/chrome-emacsclient"
;  :commands (chromeserv-find-file httpd/chromeserv/visit)
;  :after simple-httpd)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :commands (mc/mark-next-like-this mc/unmark-next-like-this mc/add-cursor-on-click)
  :bind (("M-." . mc/mark-next-like-this)
         ("M-," . mc/unmark-next-like-this)
         ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :config (setq-default save-place t))
#+END_SRC
                                                                                          
 
* Version Control
  
Without this property set to true, you would most likely jump of a
cliff. It simply loads whatever changes that happens to files outside
of emacs. Usually happens when you switch branch etc.
  
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
  
Magit]] is pretty much the de-facto interface for git in Emacs and for
good reasons. I've set it up so it suits my vim-mussles a little better.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-blame-mode
             magit-diff-popup
             magit-log-popup
             magit-statu)
  :config 
  (setq magit-no-confirm '(discard revert stage-all-changes unstage-all-changes))
  (general-define-key :prefix "SPC"))

(use-package magithub
  :after magit
  :config (magithub-feature-autoinject t))

(use-package evil-magit 
  :after magit)
#+END_SRC
  
~diff-hl~ will highlight changes in the left-margin, very much like a
fringe. It will also highlight changes in dired etc, so it's slightly
more versatile than the more popular ~git-gutter~.
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :straight t
  :config (global-diff-hl-mode t))
#+END_SRC
                                         
 
* Services

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :commands (restclient-mode restclient-http-send-current restclient-copy-curl-command))
#+END_SRC
      
 
* Aesthetics
  
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :commands (golden-ratio golden-ratio-mode)
  :diminish golden-ratio-mode
  :config (add-hook 'post-command-hook 'golden-ratio)
  :init (golden-ratio-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-default line-spacing 12
              linum-relative-current-symbol "")
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(setq-default comment-column 60)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
(setq auto-revert-verbose nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :defer 1)

(use-package all-the-icons-dired
  :after all-the-icons
  :config (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package nord-theme
  :init (load-theme 'nord t))

(use-package flatui-theme
  :disabled
  :init (load-theme 'flatui t))

(use-package flatui-dark-theme
  :disabled
  :init (load-theme 'flatui-dark t))

(use-package seti-theme
  :disabled
  :init
  (load-theme 'seti t))

(use-package sublime-themes
  :disabled
  :init
  ;; (load-theme 'brin t)
  ;; (load-theme 'hickey t)
  ;; (load-theme 'fogus t)
  ;; (load-theme 'junio t)
  )

(use-package material-theme
  :disabled
  :config
  (custom-theme-set-faces 'material
		  '(fringe ((t (:background "#181a26")))))
  :init (load-theme 'material :no-confirm))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :commands dimmer-mode
  :config (setq dimmer-percent 0.4
                dimmer-exclusion-regexp "^\*")
  :init (dimmer-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<A-up>") 'shrink-window)
(global-set-key (kbd "<A-down>") 'enlarge-window)
(global-set-key (kbd "<A-left>") 'shrink-window-horizontally)
(global-set-key (kbd "<A-right>") 'enlarge-window-horizontally)
#+END_SRC
  
I like using a GUI-version of Emacs, but I firmly dislike the amount
of chrome, this pretty much disables all of it for MacOS.
  
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(global-hl-line-mode)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(set-frame-font "Fira Code")

(use-package spinner
  :defer 1)

(use-package beacon
  :commands (beacon-mode)
  :diminish (beacon-mode . "")
  :config (beacon-mode t))

(use-package anzu
  :defer 1
  :diminish anzu-mode
  :config (global-anzu-mode t))

(use-package fullframe
  :commands magit-status
  :config (fullframe magit-status magit-mode-quit-window))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :commands linum-relative-mode
  :diminish linum-relative-mode
  :init
  (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :diminish rainbow-delimiters-mode
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :defer 1
  :diminish undo-tree-mode
  :config (defalias 'redo 'undo-tree-redo)
  :init (global-undo-tree-mode 1))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(diminish 'undo-tree-mode)
(diminish 'eldoc-mode)
(diminish 'auto-fill-function (string 32 #xa7))
(diminish 'auto-revert-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package telephone-line
  :after perspective
  :config 
  (progn
    (set-face-foreground 'persp-selected-face "SteelBlue4")
    (setq projectile-mode-line
          '(:eval (if (file-remote-p default-directory)
                      " P"
                    (format " P[%s]" (projectile-project-name))))
          telephone-line-lhs
          '((evil   . (telephone-line-evil-tag-segment))
            (accent . (telephone-line-vc-segment
                       telephone-line-erc-modified-channels-segment
                       telephone-line-process-segment))
            (nil    . (telephone-line-minor-mode-segment
                       telephone-line-buffer-segment))))
    (setq telephone-line-rhs
          '((nil . (telephone-line-misc-info-segment))
            (evil . (telephone-line-major-mode-segment))))
    (setq telephone-line-primary-right-separator 'telephone-line-abs-left
          telephone-line-secondary-right-separator 'telephone-line-abs-hollow-left)
    (setq telephone-line-height 24
          telephone-line-evil-use-short-tag t))
  :init
  (telephone-line-evil-config))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package focus
  :commands focus-mode)
#+END_SRC
                                                                                                                                                                                 
 
 * Language Support

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

Here's a list of languages that I would like to treat like lisp
#+BEGIN_SRC emacs-lisp
(setq lisp-modes '(clojure
                   lisp
                   list-interaction
                   emacs-lisp))
#+END_SRC
  
Flycheck is an on the fly linter for a whole bunch of languages. For
some languages it might cause some performance-issues, so be aware.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :defer 1
  :init (global-flycheck-mode))

(use-package flycheck-pos-tip
  :straight t
  :after (flycheck)
  :init (flycheck-pos-tip-mode))

(use-package flycheck-clojure
  :straight t
  :defer t
  :after (flycheck clojure-mode)
  :init (flycheck-clojure-setup))
#+END_SRC
  
Par-edit makes editing of s-expressions easier by keeping your
parenthesis balanced and adding key-bindings for some structural
modifications of code. It's mostly useful with lisps, but can also be
handy elsewhere as well, so learn par-edit. It's time well spent.
#+BEGIN_SRC emacs-lisp
(use-package paredit
  :commands paredit-mode
  :diminish paredit-mode
  :bind (("C-M-U" . paredit-forward-down))
  :init (add-hook-to-modes lisp-modes 'paredit-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package paxedit
  :commands paxedit-mode
  :diminish paxedit-mode
  :bind (:map paxedit-mode-map
              ("M-<right>" . paxedit-transpose-forward)
              ("M-<left>" . paxedit-transpose-backward)
              ("M-<up>" . paxedit-backward-up)
              ("M-<down>" . paxedit-backward-end)
              ("M-b" . paxedit-previous-symbol)
              ("M-f" . paxedit-next-symbol)
              ("C-%" . paxedit-copy)
              ("C-&" . paxedit-kill)
              ("C-*" . paxedit-delete)
              ("C-^" . paxedit-sexp-raise)
              ("C-w" . paxedit-backward-kill)
              ("M-w" . paxedit-forward-kill)
              ("M-u" . paxedit-symbol-change-case)
              ("C-@" . paxedit-symbol-copy)
              ("C-#" . paxedit-symbol-ki)))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :init (global-company-mode))

(use-package company-quickhelp
  :after company
  :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :disabled
  :commands flyspell-mode
  :diminish flyspell-mode
  :config (setq ispell-program-name "aspell"
                ispell-extra-args '("--sug-mode=ultra"))
  :init (progn
          (add-hook 'text-mode-hook 'flyspell-mode)
          (add-hook 'git-commit-mode-hook 'flyspell-mode)
          (add-hook 'prog-mode-hook 'flyspell-prog-mode)))

(use-package auto-dictionary
  :disabled
  :commands auto-dictionary-mode
  :init (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package auto-highlight-symbol
  :straight t
  :config  (mapc (lambda (mode)
                (add-to-list 'ahs-modes mode))
              '(clojure-mode clojurescript-mode cider-repl-mode))
  :init (global-auto-highlight-symbol-mode t))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
  (defun use-symbols ()
    "Translate some defined words into unicode symbols"
    (setq prettify-symbols-alist
	  '(("defn"       . ?∆í)
	    ("defn-"      . ? Ñ)
	    ("#("         . (?∆í (Br . Bl) ?())
	     ("fn"         . ?∆í)
	     ("#{"         . (?‚àà (Br . Bl) ?{))
	     ("->"         . ?‚Üí)
	     ("->>"        . ?‚áí)
	     ("partial"    . ?∆§)
	     ("comp"       . ?‚àò)
	     ("alpha"      . ?Œ±)
	     ("beta"       . ?Œ≤)
	     ("delta"      . ?Œî)
	     ;; ("delta-time" . '(?Œî (Br . Bl) ?T )
	     ("pi"         . ?œÄ)
	     ("not="       . ?‚â†)
	     (">="         . ?‚â•)
	     ("<="         . ?‚â§)
	     ("true"       . ?‚úì)
	     ("false"      . ?‚úò))))
#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp
(defun clojure-hook ()
  (paredit-mode t)
  (paxedit-mode t)
  (eldoc-mode t)
  (subword-mode t)
  (rainbow-delimiters-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun zprint ()
  (interactive)
  (let ((cmd (concat "lein zprint " buffer-file-name)))
    (basic-save-buffer)
    (shell-command cmd)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package inf-clojure
  :after clojure-mode
  :init (inf-clojure-minor-mode))
#+END_SRC
   
#+BEGIN_SRC emacs-lisp
(defun cider-debug-create-local-let (start end)
  (interactive "r")
  (if cider--debug-mode-response
      (nrepl-dbind-response cider--debug-mode-response (locals)
        (let* ((code (buffer-substring-no-properties start end))
               (bindings (apply #'append locals))
               (formatted-bindings (mapconcat 'identity bindings " ")))
          (kill-new (format "(let [%s]\n %s)" formatted-bindings code))
          (message "copied let form to kill ring")))
    (message "No debugging information found.")))

(use-package cider
  :after clojure-mode
  :diminish cider-mode
  :bind (:map cider-mode-map
              ("C-c f" . zprint))
  :config
  (setq nrepl-log-messages t
        nrepl-buffer-name-show-port t
        cider-repl-pop-to-buffer-on-connect nil
        cider-font-lock-dynamically '(macro core function var partial comp -> ->>)
        cider-overlays-use-font-lock t
        cider-eldoc-display-context-dependent-info t
        cider-repl-display-help-banner t
        cider-show-error-buffer t
        cider-auto-select-error-buffer t
        cider-repl-history-file "~/.eyre/cider-history"
        cider-repl-wrap-history t
        cider-repl-use-pretty-printing t
        cider-cljs-clojure-repl "clj -Sdeps '{:deps {org.clojure/clojurescript {:mvn/version \"1.10.64\"}}}' -m cljs.main -r"
        cider-cljs-lein-repl "(do (require 'figwheel-sidecar.repl-api)
                                  (figwheel-sidecar.repl-api/start-figwheel!)
                                  (figwheel-sidecar.repl-api/cljs-repl))"
        cider-pprint-fn 'fipp)
  :init
  (add-hook 'clojure-mode-hook 'use-symbols)
  (add-hook 'cider-mode-hook #'clojure-hook)
  (add-hook 'cider-repl-mode-hook #'clojure-hook)
  (global-prettify-symbols-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package re-jump
   :straight (re-jump :type git :host github :repo "oliyh/re-jump.el"))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
(defun cider-format-before-save () 
  (interactive)
  (add-hook 'before-save-hook 'cider-format-buffer t t))

(use-package clojure-mode
  :defer 1
  :commands (clojure-mode clojurescript-mode clojurec-mode)
  :mode ("\\.edn$" "\\.boot$")
  :config
  (setq clojure-align-forms-automatically t
        clojure-indent-style ':always-align
        initial-scratch-message nil)
  :init 
  (add-hook 'clojure-mode-hook 'cider-format-before-save)
  (add-hook 'clojure-mode-hook 'cider-mode))
#+END_SRC
   
#+BEGIN_SRC emacs-lisp
(use-package clj-refactor
  :after cider-mode
  :diminish clj-refactor-mode
  :config (progn
            (setq cljr-warn-on-eval nil
                  cljr-magic-requires t
                  cljr-favor-prefix-notation nil
                  cljr-favor-private-functions nil
                  cljr-auto-sort-ns t
                  cljr-clojure-test-declaration "[clojure.test :refer :all]"
                  cljr-magic-require-namespaces
                  (append cljr-magic-require-namespaces
                          '(("edn"       . "clojure.edn")
                            ("spec"      . "clojure.spec")
                            ("stest"     . "clojure.spec.test")
                            ("str"       . "clojure.string"))))
            (cljr-add-keybindings-with-prefix "C-c e")
            (advice-add 'cljr-add-require-to-ns :after
                        (lambda (&rest _)
                          (yas-next-field)
                          (yas-next-field))))
  :init
  (add-hook 'clojure-mode-hook 'clj-refactor-mode))
#+END_SRC


*** Snippets

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/separator
# name: separator
# key: -
# --
;; ${1:Heading} ${1:$(make-string (- 71 (string-width yas-text)) ?\-)}
$0
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/c
# name: comment
# key: c
# --
(comment
  $0)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/wlet
# name: wlet
# key: wlet
# --
(when-let [$2 $1]
  $3)$>
  $0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/ilet
# name: ilet
# key: ilet
# --
(if-let [$2 $1]
  $3)$>
  $0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/cond
# name: cond
# key: cond
# --
(cond
  ($1) $2
  ($3) $4
  :else $5)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/try
# name: try
# key: try
# --
(try
  $1$>
  (catch ${2:Exception} e$>
    $3$>))$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/go
# name: timeout
# key: timeout
# --
(go (<! (timeout $1))
  ($0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-fx
# name: reg-event-fx
# key: fx
# --
(re-frame/reg-event-fx
  ::$1
  (fn [{:keys [db]} [k $2]]
    $0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-db
# name: reg-event-db
# key: db
# --
(re-frame/reg-event-db
  ::$1
  (fn [db [k $2]]
    $0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-sub
# name: reg-sub
# key: sub
# --
(re-frame/reg-sub
  ::$1
  (fn [db ${2:path}]
    (get-in db $2))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/log
# name: util/log
# key: l
# --
(util/log $0)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/extract-keys
# name: extract-keys
# key: ek
# --
{:keys [${1:keys}]${2: :or {$3}}}
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/defm
# name: defmulti
# key: defm
# --
(defmulti ${1:name} ${2:"${3:docstring?}" {:arglists '([$5])}}
  (fn [${5:args}]
    $6)
  ${4::default ::default})

${4:(defmethod $1 ::default [_] $7)}

(defmethod $1 ${8:match}
  [${9:args}]
  $10)

(defmethod $1 ${11:match}
  [$9]
  $0)
#+END_SRC

** Elm
   
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :config (setq elm-format-on-save t))

;(use-package flycheck-elm
;  :after (elm-mode flycheck)
;  :init (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC
   
** Org
   
#+BEGIN_SRC emacs-lisp :exports both
(defun org-mode-defaults ()
  (turn-on-auto-fill))

(use-package org
  :bind (("C-c c" . org-capture))
  :config
  (require 'ob-tangle)
  (require 'ox-latex)
                                        ; (use-package org-habit)
  (load-library "find-lisp")
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (add-to-list 'org-latex-packages-alist '("" "listings"))
  (add-to-list 'org-latex-packages-alist '("" "color"))
  (setq org-directory (expand-file-name "~/org")
        org-default-notes-file (concat org-directory "/Notes.org")
        org-agenda-files (find-lisp-find-files org-directory "\.org$")
        org-agenda-start-with-follow-mode t
        org-hide-emphasis-markers t
        org-ditaa-jar-path "/usr/local/bin/ditaa"
        org-src-window-setup 'current-window
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0
        org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-latex-listings 'minted
        org-export-with-smart-quotes t
        org-ellipsis "‚Ä¢‚Ä¢‚Ä¢"
        org-adapt-indentation nil
        org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl"))
        org-latex-listings 'minted
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((emacs-lisp . t)
           (dot . t)
           (org . t)
           (ditaa . t)
           (clojure . t)
           (css . t)
           (haskell . t)
           (makefile . t))))
  (add-hook 'org-mode-hook 'org-mode-defaults))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-restclient
  :after (org restclient)
  :config
  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((restclient . t)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :defer 1)
#+END_SRC

I use some languages from org-mode more than others and it's kind of
tedious to write their full-name etc every time I want to blurb out
some code, so here's a few handy shortcuts

#+BEGIN_SRC emacs-lisp
                                        ; Clojure-code
(add-to-list 'org-structure-template-alist
             (list "clj" "#+BEGIN_SRC clojure\n?\n#+END_SRC" "<src lang=\"clojure\">\n?\n</src>"))

                                        ; Emacs-lisp-code
(add-to-list 'org-structure-template-alist
             (list "el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))

                                        ; Haskell-code
(add-to-list 'org-structure-template-alist
             (list "hs" "#+BEGIN_SRC haskell\n?\n#+END_SRC" "<src lang=\"haskell\">\n?\n</src>"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :defer t
  :after org)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :defer t
  :after org
  :config (setq org-bullets-bullet-list '("‚óè"))
  :init (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

I'd like to get started journaling everything that affects my
well-being and progression. That means, I would like an entry for each
day that summarizes all my flaws and achievements. It will also need a
bit or two where I reflect upon it and possibly set a goal.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      `(("a" "Automate" entry (file+datetree ,(expand-file-name (concat org-directory "/Automation.org"))) "* %^{prompt}\n\n%?")
        ("j" "Jornal" entry (file+datetree ,(expand-file-name (concat org-directory "/Journal.org"))) "* %U %?\n%i\n")))
#+END_SRC

*** Snippets

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/org-mode/doc
# name: doc
# key: #+
# --
,#+TITLE:                $1
${2:#+SUBTITLE:             $3}
,#+AUTHOR:               `user-full-name`
,#+EMAIL:                `user-mail-address`

,#+LANGUAGE:             en

,#+SEQ_TODO:             TODO(t) INPROGRESS(i) REVIEW(r@) | DONE(d) CANCELED(c@)
,#+TAGS:                 noexport(n)
,#+EXPORT_EXCLUDE_TAGS:  noexport
,#+OPTIONS:              toc:4 h:4
#+END_SRC

** Web

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :defer 1
  :config (setq web-mode-markup-indent-offset 2
                web-mode-css-indent-offset 2
                web-mode-code-indent-offset 2
                web-mode-enable-auto-closing t
                web-mode-enable-auto-quoting t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :defer 1
  :init (add-hook-to-modes '(sgml-mode-hook css-mode-hook) 'emmet-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :defer 1
  :mode ("\\.js$'" . js2-mode)
  :bind (:map js2-mode-map
              ("{" . paredit-open-curly)
              ("}" . paredit-close-curly-and-newline))
  :init (custom-set-variables
         '(js2-basic-offset 2)
         '(js2-bounce-indent-p t)
         '(tab-width 2)
         '(indent-tabs-mode nil)
         '(js2-highlight-level 3)))

(use-package ac-js2
  :after js2-mode
  :init (progn
          (add-hook 'js-mode-hook 'js2-minor-mode)
          (add-hook 'js2-mode-hook 'ac-js2-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package prettier-js
  :defer 1
  :init (add-hook 'js2-mode-hook 'prettier-js-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-tern
  :defer 1
  :config (add-to-list 'company-backends 'company-tern))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode))
#+END_SRC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
 
* Abbreviations

#+NAME: abbrev-table
| Abbreviation      | Full specimen |
|-------------------+---------------|
| very afraid       | terrified     |
| very angry        | furious       |
| very bad          | atrocious     |
| very beautiful    | exquisite     |
| very big          | immense       |
| very bright       | dazzling      |
| very capable      | accomplished  |
| very clean        | spotless      |
| very clever       | brilliant     |
| very cold         | freezing      |
| very conventional | conservative  |
| very dirty        | squalid       |
| very dry          | parched       |
| very eager        | keen          |
| very fast         | quick         |
| very fierce       | ferocious     |
| very good         | superb        |
| very happy        | jubilant      |
| very hot          | scalding      |
| very hungry       | ravenous      |
| very large        | colossal      |
| very lively       | vivacious     |
| very loved        | adored        |
| very neat         | immaculate    |
| very old          | ancient       |
| very poor         | destitute     |
| very pretty       | beautiful     |
| very quiet        | silent        |
| very risky        | perilous      |
| very roomy        | spacious      |
| very rude         | vulgar        |
| very serious      | solemn        |
| very small        | tiny          |
| very strong       | unyielding    |
| very stupid       | idiotic       |
| very tasty        | delicious     |
| very thin         | gaunt         |
| very tired        | exhausted     |
| very ugly         | hideous       |
| very valuable     | precious      |
| very weak         | feeble        |
| very wet          | soaked        |
| very wicked       | villainous    |
| very wise         | sagacious     |
| very worried      | anxious       |
| disapproval       | ‡≤†_‡≤†           |
| shrug             | ¬Ø\_(„ÉÑ)_/¬Ø    |

#+BEGIN_SRC emacs-lisp :var abbrev-table=abbrev-table
(let* ((dyn `(("@name" ,user-full-name)
              ("@mail" ,user-mail-address)))
       (abbreviations (append dyn abbrev-table)))
  (define-abbrev-table 'global-abbrev-table abbreviations))
#+END_SRC
 

* Box-specific Preferences

So Eyre does not have the layered goodness of Spacemacs and other
similar run-commands, but you can override and add your own shit as
long as you keep it locally. Touch a file at ~~/.eyre.local~ and
sprinkle it with some magical elisp-dust and you should be all set.
#+BEGIN_SRC emacs-lisp
(let ((path (expand-file-name "~/.eyre.local")))
  (when (file-exists-p path)
      (load-file path)))
#+END_SRC
           
 
* Notes of Improvement

** TODO Make fancy-symbols compatible with formatters
** TODO When reloading Eyre, perspectives should be conserved
** TODO Automatically open browser when connecting to a browser-REPL    
