#+TITLE:                Eyre
#+AUTHOR:               Henrik Kjerringvåg
#+EMAIL:                henrik@kjerringvåg.no
#+STARTUP:              overview noindent
#+SEQ_TODO:             TODO(t) INPROGRESS(i) REVIEW(r@) | DONE(d) CANCELED(c@)
#+TAGS:                 cheatsheet(c) noexport(n)
#+OPTIONS:              toc:nil num:nil author:nil date:nil
#+EXPORT_EXCLUDE_TAGS:  noexport
#+LANGUAGE:             en
#+PROPERTY:             header-args :mkdirp yes :noweb yes

#+BEGIN_QUOTE
I am no bird; and no net ensnares me; I am a free human being with
an independent will
-- Jane Eyre
#+END_QUOTE

\newpage

* Introduction
  
With the obligatory hipster-quote out of the way, we can get down to
business. With Eyre, I'm trying to make my configuration as
immediately obvious as possible. That means it's somewhat verbose, but
with the added benefit that others such as yourself could learn a
thing or two.

Emacs is so much more than an editor, it's an interactive
lisp-environment. That means you can tweak every single detail with
immidiate feedback. That makes it easier to learn and experiment
with. It also means that you can more quickly extend it to your
liking. Since Emacs is so easy to extend, there are quite a few
extensions/packages available from a variety of repositories.  One
such repository is [[https://melpa.org][melpa]]; just have a look if you have'nt already.

  
* Package Management
  
Before downloading and installing packages, I like to insert a little
tweak to the garbage-collector. This will; up the amount of memory to
use when heavier tasks are set in motion and return to the default
afterwards.
#+BEGIN_SRC emacs-lisp
(defconst MB (* 1024 1024))

(defun increase-gc () (setq gc-cons-threshold (round (* 256 MB))))

(defun decrease-gc () (setq gc-cons-threshold (round (* 0.8 MB))))

(add-hook 'minibuffer-setup-hook #'increase-gc) 
(add-hook 'minibuffer-exit-hook #'decrease-gc)
#+END_SRC

To actually manage packages, I like the combination of [[https://github.com/jwiegley/use-package][use-package]] and
[[https://github.com/raxod502/straight.el][straight.el]]. ~Straight~ will clone all of the repositories that you
specify, so you can actually make changes and push them to your own
fork and ~use-package~ is a powerful macro that makes package-management
and initialization declarative.

#+BEGIN_SRC emacs-lisp
(let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 3))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+END_SRC
 
To set up your own fork of some package, you supply a recipe to
~straight.el~ like this:
#+BEGIN_EXAMPLE emacs-lisp
(use-package el-patch :straight (el-patch :type git :host github :repo
  "your-name/el-patch" :upstream (:host github :repo "raxod502/el-patch")))
#+END_EXAMPLE

Declaring packages in your config can be tedious, so to get a quick
feel for a package you can use [[https://github.com/larstvei/Try][try]]. The packages downloaded with try
will not be persisted to the next session.
#+BEGIN_SRC emacs-lisp
(use-package try :commands try)
#+END_SRC
 

* Configuration Helpers

Below, I've listed directories and files that are important to Eyre,
these are used throughtout the configuration.
#+BEGIN_SRC emacs-lisp
(defconst conf-dir (file-name-directory load-file-name))
(defconst src-file (expand-file-name "Eyre.org" conf-dir))
(defconst savefile-dir (expand-file-name "savefile-dir" conf-dir))
(defconst backup-dir (expand-file-name "backup" conf-dir))
#+END_SRC  

Keep backup's, but keep them separate from the current project. That's
just a really annoying default.
#+BEGIN_SRC emacs-lisp
(setq-default backup-directory-alist `((".*" . , backup-dir))
              auto-save-file-name-transforms `((".*" ,backup-dir t))
              auto-save-list-file-prefix backup-dir
              create-lockfiles nil)
#+END_SRC  

The below preferences are some better-defaults in my opinion. Their
names are quite self-explanatory I think.
#+BEGIN_SRC emacs-lisp
(setq-default large-file-warning-threshold (* 2 MB)
              vc-follow-symlinks t
              delete-by-moving-to-trash t
              kill-do-not-save-duplicates t
              eshell-banner-message ""
              require-final-newline nil)
#+END_SRC

From time and again, my configuration accumulate some cruft that
weighs it down. Starting emacs with ~EMACS_BENCHMARK~ set to true
can be helpful in finding the culprit.
#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :unless (eq nil (getenv "EMACS_BENCHMARK"))
  :init (benchmark-init/activate)
  :hook ((after-init . benchmark-init/deactivate)
         (emacs-startup . benchmark-init/show-durations-tabulated)))
#+END_SRC

With [[https://www.emacswiki.org/emacs/DelightedModes][delight]] you can customize how modes are displayed in the
modeline.  It's worth noting, that it adds a ~:delight~ keyword to
~use-package~, for easier usage.
#+BEGIN_SRC emacs-lisp
(use-package delight
  :config
  (delight '((eldoc-mode)
             (rainbow-mode))))
#+END_SRC
 
Use ~y~ and ~n~ instead of ~yes~ and ~no~ when answering silly questions.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC  
 
Sometimes it's nice to just kill all other buffers than the one your
currently editing to get a clean slate.
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers than the current."
  (interactive)
  (mapc 'kill-buffer
        (delq (current-buffer)
              (remove-if-not 'buffer-file-name (buffer-list)))))

(bind-key "C-x K" 'kill-other-buffers)
#+END_SRC

If you ask me, editing as sudo should have been part of the stack of
emacs native commands, but hey..
#+BEGIN_SRC emacs-lisp
(defun sudo-edit (&optional arg)
  "Edit currently visited file as root.

   With a prefix ARG prompt for a file to visit.
   Will also prompt for a file to visit if current
   buffer is not visiting a file."
  (interactive "P")
  (let ((cursor-position (point)))
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name)))
    (goto-char cursor-position)))
#+END_SRC

I've added this little helper-function to be able to quickly jump to
this configuration-file.
#+BEGIN_SRC emacs-lisp
(defun find-configurations-file ()
  "Find Eyre's configuration-file."
  (interactive)
  (find-file src-file))
#+END_SRC

When executing ~exit~ in a terminal, the terminal-buffer will normally
remain on screen, this snippet will exit properly.
#+BEGIN_SRC emacs-lisp
(defun kill-term-buffer ()
  "Kill terminal-buffer upon quitting"
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'kill-term-buffer)
#+END_SRC

[[https://github.com/bbatsov/super-save][Super-save]] will automatically persist your buffers to files upon
certain events. Typically when emacs looses focus or you switch
between buffers etc.
#+BEGIN_SRC emacs-lisp
(use-package super-save
  :delight ""
  :config (setq super-save-auto-save-when-idle t
                super-save-idle-duration 1)
  :init (super-save-mode +1))
#+END_SRC

I haven't needed [[https://github.com/lewang/command-log-mode][command-log-mode]] yet, but it might come in
handy if I'm ever going to screencast some emacs-usage.
#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands (command-log-mode clm/toggle-command-log-buffer))
#+END_SRC
  
[[https://github.com/joddie/macrostep][Macrostep]] is a handy little package that lets you expand elisp-macros.
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands (macrostep-mode macrostep-expand)
  :bind (("C-c e" . macrostep-expand)))
#+END_SRC

[[https://github.com/jwiegley/emacs-async][Async]] does exactly what it sounds like. It can run commands
asynchronously. You can use it to byte-compile Eyre with a little
performance-boost.
#+BEGIN_SRC emacs-lisp
(use-package async
  :disabled
  :commands (dired-async-mode async-bytecomp-package-mode)
  :config (setq async-bytecomp-allowed-packages '(all))
  :init 
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package tldr)
#+END_SRC
 

* Startup
  
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message ""
      inhibit-startup-echo-area-message t
      load-prefer-newer t
      initial-major-mode 'org-mode)
#+END_SRC
  
Eyre boots directly into the agenda-view, so you can quickly jump to
the task of the day. Getting comfortable with setting up an agenda will
make you more productive. So don't fret the agenda.

#+BEGIN_SRC emacs-lisp
(use-package page-break-lines)
(use-package dashboard
  :after page-break-lines
  :init  (dashboard-setup-startup-hook)
  :config (setq dashboard-items '((agenda . 5)
                                  (projects . 5))
                dashboard-startup-banner (expand-file-name "eyre_logo.png" conf-dir)
                dashboard-banner-logo-title ""))
#+END_SRC


* Bindings
  
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :delight ""
  :init (which-key-mode)
  :config (which-key-setup-minibuffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package general
  :init
  (general-evil-setup t)
  :config
  (setq general-default-keymaps 'evil-normal-state-map)
  (general-define-key :prefix "SPC"
                      "SPC" 'avy-goto-char-timer
                      "'" 'projectile-run-eshell
                      "bs" 'ivy-switch-buffer
                      "fc" 'find-configurations-file
                      "gs" 'magit-status
                      "pf" 'counsel-projectile-find-file
                      "ps" 'counsel-projectile-switch-project
                      "p/" 'counsel-projectile-ripgrep))
#+END_SRC


* Working with text & code

** Navigation

I'm very much a proponent of mostly using the keyboard, as it does
increase efficieny. But a lot of times I need to grok some already
existing code-base and doing so, I like to lean back, read and
navigate mostly using mouse-scroll.
#+BEGIN_SRC emacs-lisp
(xterm-mouse-mode t)
#+END_SRC

It's also useful both when editing and reading, to be able to narrow
into a piece of code without surrounding distractions.
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

Hitting ~C-c n~ I can quicly narrow and widen to the selected region; ahhh...
Found this when googling https://gist.github.com/mwfogleman/95cc60c87a9323876c6c
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim ()
  "If the buffer is narrowed, it widens. Otherwise, it narrows to region, or Org subtree."
  (interactive)
  (cond ((buffer-narrowed-p) (widen))
        ((region-active-p) (narrow-to-region (region-beginning) (region-end)))
        ((equal major-mode 'org-mode) (org-narrow-to-subtree))
        (t (error "Please select a region to narrow to"))))

(bind-key "C-c n" 'narrow-or-widen-dwim)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char-timer avy-goto-line avy-goto-word-1)
  :bind (("M-g c" . avy-goto-char-timer)
         ("M-g l" . avy-goto-line)
         ("M-g w" . avy-goto-word-1))
  :config
  (setq avy-style 'de-bruijn))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :straight t
  :delight ""
  :config (setq ivy-use-virtual-buffers t
                ivy-initial-inputs-alist nil)
  :init (ivy-mode 1))

(use-package wgrep
  :straight t
  :config (setq wgrep-change-readonly-file t
                wgrep-enable-key "e"))

(use-package historian
  :straight t
  :commands (historian-mode)
  :after ivy
  :config (historian-mode +1))

(use-package ivy-historian
  :straight t
  :commands (ivy-historian-mode)
  :after (ivy historian)
  :config (ivy-historian-mode +1))

(use-package swiper
  :straight t
  :after ivy
  :bind ("C-s" . swiper))

;; TODO Make wgrep work with ivy
;; TODO M-x should start out blank
;; Stolen from spacemacs
;; (defun counsel-edit ()
;;   (interactive)
;;   (run-with-idle-timer 0 nil 'ivy-wgrep-change-to-wgrep-mode))

(use-package counsel
  :straight t
  :after ivy
  :bind (("M-x" . counsel-M-x)
         ;; ("C-c C-e" . counsel-edit)
         ("C-h v" . counsel-describe-variable)
         ("C-h f" . counsel-describe-function))
  :config (setq counsel-grep-base-command
                "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

   (use-package helpful
     :straight t)

   (use-package counsel-projectile
     :straight t
     :after counsel)

(use-package prescient
  :config (prescient-persist-mode +1))

(use-package ivy-prescient
  :after (prescient ivy)
  :config (ivy-prescient-mode +1))

(use-package company-prescient
  :after (prescient company)
  :config (company-prescient-mode +1))
#+END_SRC

*** Projects

#+BEGIN_SRC emacs-lisp
(use-package ripgrep
  :straight t
  :when (executable-find "rg")
  :commands (ripgrep-regexp))

(use-package ag
  :straight t
  :commands (ag ag-project ag-regexp))
#+END_SRC

Navigating within projects can be achieved with [[https://projectile.readthedocs.io/en/latest/][projectile]].
#+BEGIN_SRC emacs-lisp
(defun open-project-at ()
  (progn
    (find-file (concat default-directory "/README*") t)
    (if (file-exists-p (concat default-directory "/.git"))
        (magit-status)
      (projectile-find-file))))

(use-package projectile
  :delight ""
  :commands (projectile-mode projectile-dired projectile-shell projectile-find-file projectile-ripgrep)
  :config (setq projectile-switch-project-action 'open-project-at
                projectile-completion-system 'ivy)
  :init (projectile-global-mode))
#+END_SRC

And jumping between projects can be achieved with [[https://github.com/bbatsov/persp-projectile][perspective]].
#+BEGIN_SRC emacs-lisp
(use-package perspective
  :delight ""
  :straight (perspective :type git
                         :host github
                         :repo "hkjels/perspective-el"
                         :branch "no-frame-local-vars"
                         :upstream (:host github :repo "nex3/perspective-el"))
  :config (persp-mode t))

(use-package persp-projectile
  :straight (persp-projectile :type git
                              :host github
                              :repo "hkjels/persp-projectile"
                              :branch "frame-perspective-hash"
                              :upstream (:host github :repo "bbatsov/persp-projectile"))
  :after (perspective projectile))
#+END_SRC

** Efficient Editing

Show key-stroke in minibuffer pronto
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.02)
#+END_SRC
  
Behave nicely amongst other editors
#+BEGIN_SRC emacs-lisp
(use-package editorconfig)
#+END_SRC

Evil introduces modal-bindings to emacs, similar to that of vim. As a
longtime vim-user, I must say it's like editing super-powers that I
can not leave behind.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :straight t
  :bind (:map evil-normal-state-map
              ("M-." . nil)
              ("M-," . nil))
  :init (evil-mode 1))

(use-package evil-iedit-state :after evil)

(use-package evil-exchange :after evil)

(use-package evil-ediff :after evil)

(use-package evil-numbers
  :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
  :bind (("M-+" . evil-numbers/inc-at-pt)
         ("M--" . evil-numbers/dec-at-pt)))

(use-package evil-surround
  :after evil
  :init (global-evil-surround-mode 1))
#+END_SRC

[[https://github.com/bling/evil-visualstar][evil-visualstart]] allows star and hash-searches to be performed on a
visual-selection

#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :after evil
  :config (setq evil-visualstar/persistent t)
  :init (global-evil-visualstar-mode))

(use-package evil-commentary
  :after evil
  :delight ""
  :config (evil-commentary-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :straight t
  :bind ("C-=" . er/expand-region))
#+END_SRC

Par-edit makes editing of s-expressions easier by keeping your
parenthesis balanced and adding key-bindings for some structural
modifications of code. It's mostly useful with lisps, but can also be
handy elsewhere as well, so learn par-edit. It's time well spent.
#+BEGIN_SRC emacs-lisp
(use-package paredit
  :delight ""
  :hook ((lisp-mode
          lisp-interaction-mode
          emacs-lisp-mode
          eval-expression-minibuffer-setup-mode) . paredit-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil-cleverparens
  :after paredit
  :hook ((lisp-mode
          lisp-interaction-mode
          emacs-lisp-mode
          eval-expression-minibuffer-setup
          cider-mode
          cider-repl-mode) . evil-cleverparens-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package use-package-chords
  :init (key-chord-mode 1)
  :config (setq key-chord-two-keys-delay 0.05))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ac-emoji
  :hook ((markdown-mode git-commit-mode) . ac-emoji-setup)
  :config (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)
  :init (ac-emoji-setup))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :commands (mc/mark-next-like-this mc/unmark-next-like-this mc/add-cursor-on-click)
  :bind (("M-." . mc/mark-next-like-this)
         ("M-," . mc/unmark-next-like-this)
         ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :config (setq-default save-place t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ialign
  :commands (ialign)
  :bind (("M-l" . ialign)))
#+end_SRC

#+BEGIN_SRC emacs-lisp
(use-package bool-flip
  :commands (bool-flip-do-flip)
  :bind (:map evil-normal-state-map
              ("-" . bool-flip-do-flip)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :hook (prog-mode . hs-minor-mode))
#+END_SRC

;; I'm a big proponent of ~org-mode~ and have found it's outlines to be
;; one of it's most killer features. I've also discovered that you can
;; have pretty good outlines without ~org-mode~, so ...
;; 
;; #+BEGIN_SRC emacs-lisp
;; (use-package outline-mode
;;   :straight nil
;;   :hook prog-mode)
;; 
;; (use-package outorg
;;   :straight t
;;   :hook prog-mode
;;   :config (setq outline-minor-mode-prefix "\M-#"))
;; 
;; (use-package outshine
;;   :straight t
;;   :after outline
;;   :hook (outline-minor-mode . outshine-hook-function))
;; 
;; (use-package outline-ivy
;;   :straight (outline-ivy :type git :host github :repo "hkjels/outline-ivy-mirror")
;;   :commands (oi-jump))
;; #+END_SRC

** Templating

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish  yas-minor-mode
  :config (yas/load-directory "~/.eyre/snippets")
  :init (yas-global-mode t))
#+END_SRC

** Version Control
  
Without this property set to true, you would most likely jump of a
cliff. It simply loads whatever changes that happens to files outside
of emacs. Usually happens when you switch branch etc.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gist)
#+END_SRC
  
Magit is pretty much the de-facto interface for git in Emacs and for
good reasons. I've set it up so it suits my vim-mussles a little better.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-blame-mode
             magit-diff-popup
             magit-log-popup
             magit-status)
  :config 
  (setq magit-no-confirm '(discard revert stage-all-changes unstage-all-changes)))

(use-package magithub
  :after magit
  :config (magithub-feature-autoinject t))

(use-package evil-magit 
  :after magit)
#+END_SRC
  
~diff-hl~ will highlight changes in the left-margin, very much like a
fringe. It will also highlight changes in dired etc, so it's slightly
more versatile than the more popular ~git-gutter~.
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :init (global-diff-hl-mode t))
#+END_SRC

** Language

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8-unix)
(set-language-environment 'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system 'utf-8
      file-name-coding-system 'utf-8-unix
      buffer-file-coding-system 'utf-8-unix)

(setq tab-always-indent 'complete)
#+END_SRC
   
Flycheck is an on the fly linter for a whole bunch of languages. For
some languages it might cause some performance-issues, so be aware.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish flycheck-mode
  :init (global-flycheck-mode)
  :general
  (:keymaps
   'flycheck-mode-map
   "M-j" #'flycheck-next-error
   "M-k" #'flycheck-previous-error)
  :general
  (:states
   'motion
   :keymaps 'flycheck-error-list-mode-map
   "j" #'flycheck-error-list-next-error
   "k" #'flycheck-error-list-previous-error
   "RET" #'flycheck-error-list-goto-error
   "q" #'quit-window))

(use-package flycheck-pos-tip
  :after flycheck
  :init (flycheck-pos-tip-mode))

(use-package flycheck-clojure
  :after cider
  :config (flycheck-clojure-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company
  :delight ""
  :init (global-company-mode))

(use-package company-quickhelp
  :delight ""
  :after company
  :hook (global-company-mode . company-quickhelp-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :disabled
  :after exec-path-from-shell
  :delight ""
  :commands flyspell-mode
  :config (setq ispell-program-name "aspell"
                ispell-extra-args '("--sug-mode=ultra"))
  :hook ((text-mode git-commit-mode prog-mode-hook) . flyspell-prog-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package powerthesaurus
  :commands (powerthesaurus-lookup-word)
  :bind (("C-x p" . powerthesaurus-lookup-word)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package wordnut
  :commands (wordnut-search wordnut-lookup-current-word)
  :bind (("C-x /" . wordnut-search)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :hook ((org-mode text-mode) . writegood-mode))
#+END_SRC

*** Abbreviations

#+NAME: abbrev-table
| Abbreviation      | Full specimen |
|-------------------+---------------|
| very afraid       | terrified     |
| very angry        | furious       |
| very bad          | atrocious     |
| very beautiful    | exquisite     |
| very big          | immense       |
| very bright       | dazzling      |
| very capable      | accomplished  |
| very clean        | spotless      |
| very clever       | brilliant     |
| very cold         | freezing      |
| very conventional | conservative  |
| very dirty        | squalid       |
| very dry          | parched       |
| very eager        | keen          |
| very fast         | quick         |
| very fierce       | ferocious     |
| very good         | superb        |
| very happy        | jubilant      |
| very hot          | scalding      |
| very hungry       | ravenous      |
| very large        | colossal      |
| very lively       | vivacious     |
| very loved        | adored        |
| very neat         | immaculate    |
| very old          | ancient       |
| very poor         | destitute     |
| very pretty       | beautiful     |
| very quiet        | silent        |
| very risky        | perilous      |
| very roomy        | spacious      |
| very rude         | vulgar        |
| very serious      | solemn        |
| very small        | tiny          |
| very strong       | unyielding    |
| very stupid       | idiotic       |
| very tasty        | delicious     |
| very thin         | gaunt         |
| very tired        | exhausted     |
| very ugly         | hideous       |
| very valuable     | precious      |
| very weak         | feeble        |
| very wet          | soaked        |
| very wicked       | villainous    |
| very wise         | sagacious     |
| very worried      | anxious       |
| disapproval       | ಠ_ಠ           |
| shrug             | ¯\_(ツ)_/¯    |

#+BEGIN_SRC emacs-lisp :var abbrev-table=abbrev-table
;; (let* ((dyn `(("@name" ,user-full-name)
;;               ("@mail" ,user-mail-address)))
;;        (abbreviations (append dyn abbrev-table)))
;;   (define-abbrev-table 'global-abbrev-table abbreviations))
#+END_SRC

*** Emacs lisp

With [[https://github.com/Malabarba/names][names]] you can write emacs-packages with complete namespaces
using ~(define-namespace package-)~
#+BEGIN_SRC emacs-lisp
(use-package names
  :straight t)
#+END_SRC

[[https://github.com/Malabarba/Nameless][Nameless]] hides package namespaces for brevity
#+BEGIN_SRC emacs-lisp
(use-package nameless
  :straight t
  :commands (nameless-mode)
  :hook (emacs-lisp-mode . nameless-mode))
#+END_SRC

*** Org
    
Unfortunately, straight is not able to install org-mode properly at
the time of writing, so we have to apply a hack.
#+BEGIN_SRC emacs-lisp
(use-package org
  :init
  (defun org-git-version ()
    (require 'git)
    (let ((git-repo (expand-file-name "straight/repos/org/" user-emacs-directory)))
      (string-trim (git-run "describe" "--match=release\*" "--abbrev=6" "HEAD"))))

  (defun org-release ()
    (require 'git)
    (let ((git-repo (expand-file-name "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix "release_" (git-run "describe" "--match=release\*" "--abbrev=0" "HEAD")))))

  (provide 'org-version)
  :config
  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((clojure . t)
           (ditaa . t)
           (dot . t)
           (emacs-lisp . t)
           (haskell . t)
           (makefile . t)
           (sed . t)
           (shell . t))))
  (setq org-directory "~/org"
        org-export-in-background t
        org-insert-heading-respect-content t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header 
  :after org
  :hook (org-mode . org-sticky-header-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :disabled
  :after org
  :hook (org-mode . org-bullets-mode)
  :config (setq org-bullets-bullet-list '("●")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :straight nil
  :after org
  :config
  (setq org-edit-src-content-indentation 0
        org-src-fontify-natively t
        org-src-window-setup 'current-window))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :straight org)
#+END_SRC

#+BEGIN_SRC emacs-lisp
; Clojure-code
(add-to-list 'org-structure-template-alist
             (list "clj" "#+BEGIN_SRC clojure\n?\n#+END_SRC" "<src lang=\"clojure\">\n?\n</src>"))

; Emacs-lisp-code
(add-to-list 'org-structure-template-alist
             (list "el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))

; Haskell-code
(add-to-list 'org-structure-template-alist
             (list "hs" "#+BEGIN_SRC haskell\n?\n#+END_SRC" "<src lang=\"haskell\">\n?\n</src>"))
#+END_SRC

*** Docker
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode)
#+END_SRC

*** Git
#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode)
(use-package gitconfig-mode)
#+END_SRC

*** Terraform
#+BEGIN_SRC emacs-lisp
(use-package terraform-mode)
#+END_SRC
*** Clojure

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :straight t
  :config (setq clojure-align-forms-automatically t
                clojure-indent-style ':always-align
                initial-scratch-message nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package cider
  :straight t
  :after clojure-mode
  :hook ((cider-mode cider-repl-mode) . paredit-mode))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/separator
# name: separator
# key: -
# --
;; ${1:Heading} ${1:$(make-string (- 71 (string-width yas-text)) ?\-)}
$0
#+END_SRC


#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/c
# name: comment
# key: c
# --
(comment
$0)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/wlet
# name: wlet
# key: wlet
# --
(when-let [$2 $1]
$3)$>
$0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/ilet
# name: ilet
# key: ilet
# --
(if-let [$2 $1]
$3)$>
$0$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/cond
# name: cond
# key: cond
# --
(cond
($1) $2
($3) $4
:else $5)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/try
# name: try
# key: try
# --
(try
$1$>
(catch ${2:Exception} e$>
$3$>))$>
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/go
# name: timeout
# key: timeout
# --
(go (<! (timeout $1))
($0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-fx
# name: reg-event-fx
# key: fx
# --
(re-frame/reg-event-fx
::$1
(fn [{:keys [db]} [k $2]]
$0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-event-db
# name: reg-event-db
# key: db
# --
(re-frame/reg-event-db
::$1
(fn [db [k $2]]
$0))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/reg-sub
# name: reg-sub
# key: sub
# --
(re-frame/reg-sub
::$1
(fn [db ${2:path}]
(get-in db $2)))
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/log
# name: util/log
# key: l
# --
(util/log $0)
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/extract-keys
# name: extract-keys
# key: ek
# --
{:keys [${1:keys}]${2: :or {$3}}}
#+END_SRC

#+BEGIN_SRC snippet :tangle ~/.eyre/snippets/clojure-mode/defm
# name: defmulti
# key: defm
# --
(defmulti ${1:name} ${2:"${3:docstring?}" {:arglists '([$5])}}
(fn [${5:args}]
$6)
${4::default ::default})

${4:(defmethod $1 ::default [_] $7)}

(defmethod $1 ${8:match}
[${9:args}]
$10)

(defmethod $1 ${11:match}
[$9]
$0)
#+END_SRC


* Aesthetics

The chrome for Emacs-GUI could definitely be improved and arguably is,
by just turning it off. I like it.
#+BEGIN_SRC emacs-lisp
(when window-system 
  (blink-cursor-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (fringe-mode '(3 . 1)))
#+END_SRC
 
I've noticed some call these kinds of preferences "better defaults"
however, mine are not the same as everyone elses, so it might just be
better for me. SRY!
#+BEGIN_SRC emacs-lisp
(setq-default line-spacing 15             ;; Adds some more space between lines
              truncate-lines t            ;; Disables line-wrapping
              indent-tabs-mode nil        ;; Use spaces for indentation
              scroll-margin 10            ;; Add some space when scrolling
              comment-column 60           ;; Hard-wrap comments at 60 columns
              visible-bell t              ;; Disables audio-bell
              ring-bell-function 'ignore  ;; Disables the a big yellow triangle
              x-stretch-cursor t          ;; Make the cursor span the entire with of the character below
              auto-revert-verbose nil)    ;; Disable messages about reverting buffers

(global-hl-line-mode)
(show-paren-mode t)
(set-frame-font "Fira Code")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package sublimity
  :straight t
  :init (require 'sublimity-attractive)
  :config (sublimity-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :straight t)

(use-package all-the-icons-dired
  :after all-the-icons
  :commands (all-the-icons-dired-mode)
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package all-the-icons-ivy
  :after (all-the-icons ivy)
  :config 
  (all-the-icons-ivy-setup)
  (setq all-the-icons-ivy-file-commands
        '(counsel-find-file counsel-file-jump counsel-recentf counsel-projectile-find-file counsel-projectile-find-dir)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :straight t
  :hook ((emacs-lisp-mode clojure-mode) . aggressive-indent-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :commands (dired-sidebar-toggle-sidebar)
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :config (setq dired-sidebar-close-sidebar-on-file-open t))

(use-package dired-subtree
  :after dired-sidebar
  :bind (:map dired-mode-map
              ("i" . dired-subtree-toggle)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dracula-theme
  :straight t)

(use-package nord-theme
  :straight t
  :init (load-theme 'nord :no-confirm))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :commands dimmer-mode
  :config (setq dimmer-percent 0.4
                dimmer-exclusion-regexp "^\*")
  :init (dimmer-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package spinner)

(use-package beacon
  :commands (beacon-mode)
  :delight ""
  :config (beacon-mode t))

(use-package anzu
  :delight ""
  :config (global-anzu-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :delight ""
  :init (global-undo-tree-mode 1)
  :config
  (general-define-key
   :states 'motion
   :keymaps '(undo-tree-visualizer-mode-map
              undo-tree-visualizer-selection-mode-map)
   "j" 'undo-tree-visualize-redo
   "k" 'undo-tree-visualize-undo
   "h" 'undo-tree-visualize-switch-branch-right
   "l" 'undo-tree-visualize-switch-branch-left)
  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package focus
  :commands focus-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package linum-relative
  :commands linum-relative-mode
  :delight ""
  :hook (prog-mode . linum-relative-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :delight ""
  :commands rainbow-delimiters-mode
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode
  :hook (prog-mode . rainbow-mode))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(use-package shackle
  :config
  (add-hook 'eshell-exit-hook 'delete-window)
  (setq shackle-rules
        '(("^magit: .*" :regexp t :same t)
          (magit-diff-mode :noselect t)
          ("\\`\\*e?shell" :regexp t :align below :size 0.35 :popup t)
          ("\\`\\*B?enchmark Init" :regexp t :align below :size 0.35 :popup t)
          ("*WordNut*" :align below :size 0.35 :popup t)
          ("*undo-tree*" :size 0.3 :align right)
          ("*Help*" :align right))
        shackle-default-rule '(:select t))
  (shackle-mode 1))
#+END_SRC
                                                                                                                                                                                 
** Modeline

#+BEGIN_SRC emacs-lisp
(defconst modeline:blank " ")
(defconst modeline:blank2 (concat modeline:blank modeline:blank))
(defconst modeline:blank4 (concat modeline:blank2 modeline:blank2))
(defconst modeline:separator (propertize "»"))
(defconst modeline:separator-group (concat modeline:blank2 modeline:separator modeline:blank2))

(defconst modeline:symbol-directory-local
  (propertize
   (all-the-icons-octicon "dash")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-directory-remote
  (propertize
   (all-the-icons-octicon "sync")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-status
  (propertize
   (all-the-icons-octicon "info")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-up-to-date
  (propertize
   (all-the-icons-octicon "check")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-edited
  (propertize
   (all-the-icons-octicon "keyboard")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-needs-added
  (propertize
   (all-the-icons-octicon "pencil")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-needs-removed
  (propertize
   (all-the-icons-octicon "pencil")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-needs-conflict
  (propertize
   (all-the-icons-octicon "pencil")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-unergistered
  (propertize
   (all-the-icons-octicon "pencil")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-vc-branch
  (propertize
   (all-the-icons-octicon "git-branch")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-flycheck-no-issues
  (propertize
   (all-the-icons-octicon "check")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-flycheck-issues
  (propertize
   (all-the-icons-octicon "bug")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-flycheck-running
  (propertize
   (all-the-icons-octicon "sync")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-flycheck-errored
  (propertize
   (all-the-icons-octicon "alert")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-flycheck-interrupted
  (propertize
   (all-the-icons-octicon "alert")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-buffer-modified
  (propertize
   (all-the-icons-octicon "quote")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defconst modeline:symbol-buffer-locked
  (propertize
   (all-the-icons-octicon "lock")
   'face `(:family ,(all-the-icons-octicon-family))
   'display '(raise 0.10)))

(defun modeline:buffer-modified ()
  (let ((indicator (format-mode-line "%*")))
    (cond ((string= indicator "-") modeline:symbol-buffer-saved)
          ((string= indicator "*") modeline:symbol-buffer-modified)
          ((string= indicator "%") modeline:symbol-buffer-locked))))

(defun modeline:remote ()
  (let ((indicator (format-mode-line "%@")))
    (cond ((string= indicator "-") modeline:symbol-directory-local)
          ((string= indicator "@") modeline:symbol-directory-remote))))

(defun modeline:vc-enabled ()
  (and
   (not (null (buffer-file-name)))
   (not (null (vc-state buffer-file-name)))))

(defun modeline:vc ()
  (let* ((branch
          (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-"))
         (status
          (vc-state buffer-file-name))
         (status-icon
          (cond
           ((eq status 'edited) modeline:symbol-vc-edited)
           ((eq status 'up-to-date) modeline:symbol-vc-up-to-date)
           (t modeline:symbol-vc-status)))
         (status-name
          (symbol-name status)))
    (concat
     ;; status-icon modeline:blank status-name modeline:blank
     modeline:symbol-vc-branch modeline:blank branch)))

(defun modeline:flycheck-enabled ()
  (not
   (member flycheck-last-status-change
           '(no-checker not-checked suspicious))))

(defun modeline:flycheck ()
  (let* ((flycheck-errors (flycheck-count-errors flycheck-current-errors))
         (num-issues
          (let-alist flycheck-errors
            (+ (or .warning 0) (or .error 0))))
         (num-errors (or (cdr (assoc 'error flycheck-errors)) 0))
         (num-warnings (or (cdr (assoc 'warning flycheck-errors)) 0))
         (status flycheck-last-status-change)
         (status-icon
          (cond
           ((and
             (eq status 'finished) (= num-issues 0))
            modeline:symbol-flycheck-no-issues)
           ((and
             (eq status 'finished) (> num-issues 0))
            modeline:symbol-flycheck-issues)
           ((eq status 'running) modeline:symbol-flycheck-running)
           ((eq status 'errored) modeline:symbol-flycheck-errored)
           ((eq status 'interrupted) modeline:symbol-flycheck-interrupted)))
         (status-message
          (cond
           ((and (eq status 'finished) (= num-issues 0)) "no issues")
           ((and (eq status 'finished) (> num-issues 0))
            (concat
             (propertize (format "%d" num-errors) 'face 'bold)
             " errors "
             (propertize (format "%d" num-warnings) 'face 'bold)
             " warnings"))
           ((eq status 'running) "running")
           ((eq status 'errored) "error")
           ((eq status 'interrupted) "interrupted"))))
    (concat status-icon modeline:blank status-message)))

(defun modeline:major-mode ()
  (downcase mode-name))

(let ((bg (face-attribute 'default :background)))
  (custom-set-faces
   `(mode-line ((t (:box (:line-width 1 :color ,bg)))))))

(set-default 'mode-line-format
             (list
              modeline:blank2
              '(:eval (when (modeline:flycheck-enabled) (concat (modeline:flycheck) modeline:blank2)))
              ;; modeline:buffer-modified
              ;; modeline:remote
              mode-line-buffer-identification
              modeline:separator-group
              mode-line-modes
              modeline:separator-group
              '(:eval (when (modeline:vc-enabled) (modeline:vc)))))
#+END_SRC


* Box-Specific Preferences

** MacOS Defaults

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :straight nil
  :when (eq system-type 'darwin)
  :init 
  (setq mac-option-key-is-meta nil
        mac-command-key-is-meta t
        mac-command-modifier 'meta
        mac-option-modifier nil))

(use-package exec-path-from-shell
  :straight t
  :if (eq system-type 'darwin)
  :commands exec-path-from-shell-initialize
  :init (exec-path-from-shell-initialize))
#+END_SRC

** Addition Local Configuration

So Eyre does not have the layered goodness of Spacemacs and other
similar run-commands, but you can override and add your own shit as
long as you keep it locally. Touch a file at ~~/.eyre.local~ and
sprinkle it with some magical elisp-dust and you should be all set.
#+BEGIN_SRC emacs-lisp
(let ((path (expand-file-name "~/.eyre.local")))
  (when (file-exists-p path)
    (load-file path)))
#+END_SRC


* Notes of Improvement
** TODO Hydrated Bindings for most used Modes
** TODO Emacs-holylight
** TODO Automatically start repl from dirlocals
